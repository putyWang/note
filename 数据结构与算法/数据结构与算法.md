# 第一章 基础知识

## 一.数学基础知识

### 1.级数

#### (1)$$i^k$$的级数

- 使用归纳法证明
  - 基准情形：确定定理对于一小部分（如$$i=1$$时）是正确的；
  - 归纳假设：扩展到如$$i=n$$时适用；
- 定理一

$$
\sum_{i=0}^N i = \frac{(N(N+1))}{2} \approx \frac{N^2}{2}
$$

- 定理二

$$
\sum_{i=0}^N i^2 = \frac{(N(N+1)(2N+1))}{3} \approx \frac{N^3}{3}
$$

- 定理三

$$
\sum_{i=0}^N i^k \approx \frac{N^{k+1}}{|k+1|}
$$

#### (2)调和数（$$H_n$$）

- 当上述公式中$$k=-1$$时，最后一个公式由于$$k+1=0$$导致该式子无法成立；

- 这时就可以使用调和数Hn来表示该式的结果；
  $$
  H_N = \sum_{i=1}^N \frac{1}{i} \approx log_eN
  $$

- 上述近似式的误差趋向于$$\gamma \approx 0.57721566$$ ，称为欧拉常数。

#### (3)级数运算

$$
\sum_{i=1}^N f(N) = Nf(N)
$$

$$
\sum_{i=n_0}^N f(i) = \sum_{i=1}^N f(i) - \sum_{i=1}^{n_0 - 1} f(i)
$$

### 2.递归

#### (1)定义

- 递归就是函数用自己来定义；
- 递归并不是一个循环推理（circular logic）；
  - 循环推理：使用$$f(5)$$来得到$$f(5)$$这样的运算就是循环推理；
  - 递归：递归通常采用$$f(4)$$来得到$$f(5)$$这样的形式；

#### (2)四大准则

- 基准情形：就是无需递归就可得出的某些基本情形，就是递归最终要达到的停止情形，每个递归必须拥有基准情形；
- 不断推进：对于需要递归求解的情形，需要在每次递归之中不断向基准情形靠近；
- 设计法则：所有的递归应该都是可以正常运行；
- 合成效益法则：对同一实例进行处理时，切勿在不同递归调用中做重复性工作；

### 3.算法分析基础

#### (1)四大定义

- 如果存在正常c和$$n_o$$，使得当$$N\geqq n_o$$时$$T(N)\leqq cf(n_o)$$，则记为$$T(N)= O(f(N))$$;

- 如果存在正常c和$$n_o$$，使得当$$N\geqq n_o$$时$$T(N)\geqq cg(n_o)$$，则记为$$T(N)= \Omega(f(N))$$;

- 当且仅当$$T(N)= O(f(N))$$和$$T(N)= \Omega(f(N))$$，则$$T(N)= \Theta(h(N))$$;

- 如果存在正常c和$$n_o$$，使得当$$N> n_o$$时$$T(N)< cp(n_o)$$，则记为$$T(N)= o(f(N))$$，有时也可以说，如果$$T(N)= O(f(N))$$且$$T(N)\neq \Theta(h(N))$$，则记为$$T(N)= o(f(N))$$;

#### (2)法则

- 如果$$T_1(N)= O(f(N))$$和$$T_2(N)= O(g(N))$$; 
  - $$T_1(N) + T_2(N)= O(f(N) + g(N))$$（直观可以写成$$max(O(f(N)), O(g(N)))$$;
  - $$T_1(N) * T_2(N)= O(f(N) * g(N))$$;
- 如果$$T(N)$$是一个k次多项式，则$$T(N)= \Theta(h(N))$$;
- 对任意常数k，$$log^k N = O(N)$$；
- 典型增长率

|    函数     | 名称       |
| :---------: | ---------- |
|      c      | 常数       |
|  $$log N$$  | 常数       |
| $$log^2 N$$ | 对数平方的 |
|      N      | 线性的     |
| $$Nlog N$$  |            |
|   $$N^2$$   | 二次的     |
|   $$N^3$$   | 三次的     |
|   $$2^N$$   | 指数的     |

## 二.java基础知识

### 1.泛型

#### (1)泛型机制

- 在除去基本类型以外，实现的方法是相同的，就可以使用泛型机制实现这种功能；

- 泛型机制就是用来描述这种基本功能的机制；

- java中使用Object类实现泛型机制；

- 协变数值类型：java类型应该不是类型兼容，但在java数组中却是类型兼容的；

- 在声明类时使用菱形运算符（<>）实现泛型；

  ```java
  /**
  *设置泛型
  */
  class IntStore<T extends Object>{
      //定义泛型对象
      private T[] max;
  
      public T[] getMax() {
          return max;
      }
  
      public void setMax(T[] max) {
          this.max = max;
      }
  }
  ```

#### (2)基本类型的包装

- 包装类是用来存储基本类的类型，并添加一些基本类不能支持或不能正确支持的操作；
- java中的包装类的包装对象是不可变的（状态是不可变的），存储对象构建时所设置原值，并提供方法获取该原值；
- 自动装箱：将一个基本数据类型的值赋予给包装类型时自动调用包装类型的构造方法将数值赋予包装类型；
- 自动拆箱：将一个基本数据类型的值赋予给包装类型时自动调用包装类型的取值方法（java1.5之前Integer类中的intValue()方法）获取包装类型中的数值；

#### (3)通配符

- 通配符用来表示参数类型的子类（或者超类）；

- 使用IntStore<? extends Integer>表示；

  ```java
      static void printInteger(IntStore<? extends Integer> s){
          for (int i = 0; i < s.getMax().length; i++) {
              System.out.print(s.getMax()[i] + " ");
          }
      }
  ```

#### (4)泛型static方法

- 用于定义static所有要使用的特定类型，放在static之后；

- 可以用于定义特定的返回值类型；

- 可以用于声明一个局部变量；

- 可以用于多于一个的参数类型中；

  ```java
  static<T extends Integer> T findMax(IntStore<T> s){
      T max = s.getMax()[0];
      for (T i : s.getMax()) {
          if(max.compareTo(i) == -1)
              max = i;
      }
      return max;
  }
  ```

#### (5)类型擦除

- 在虚拟机类编译过程中，将泛型类转换为非泛型类；
- 原始类：编译器通过类型擦除，生成与泛型类同名的原始类；
- 类型擦除生成的代码与本身的代码没有区别，不能提升程序运行速度；
- 优点：编译器进行类型检验，而不是程序员自己进行类型转换；

#### (6)泛型使用的限制

- 基本数据类型不能作为类型参数，只能使用包装类型；
- instanceOf检测和类型转换工作只对原始类型进行；
- 泛型类中static方法和static域均不可引用类的类型变量；
- 不能创建一个泛型类型的实例或者泛型数组对象；
- 不能对参数化类型的数组进行实例化；

### 2.函数对象（function object)

- 该类是一个没有数据只有一个方法的类；
- 将泛型对象放在方法内部进行传递；

## 三.运行时间分析

### 1.一般法则

#### (1)for循环

- for循环的运行时间至多是该for循环内部哪些语句的运行时间乘以迭代次数；

#### (2)嵌套for循环

- 从里向外顺序分析循环；
- 在一组嵌套循环内部的一条语句总的运行时间为该语句的运行时间乘以改组中所有的for循环的大小和乘积；

#### (3)顺序语句

- 将各个语句的运行时间求和即可；

#### (4)if/else语句

- 一个if/else语句的运行时间不超过判断的运行时间加上，判断内容最长的运行时间；

### 2.运行时间的对数

#### (1)折半查找

#### (2)欧几里得算法

- 计算公约数的欧几里得算法

```java
public static long gcd(long m, long n){
    while (n != 0){
        long rem = m % n;
        m = n;
        n = rem;
    }
    
    return m;
}
```

- 定理
  - 如果$$M>N$$，则$$M mod N < M/2$$;

#### (3)幂运算

```java
public static long pow(long x, int n){
    if (n == 0)
        
        return 1;
    if (n == 1)
        return x;
    
    if (n % 2 == 0)
        
        return pow (x * x, n/2);
    else
        
        return pow (x * x, n/2) * x;
    
}
```

# 第二章  基本数据结构

## 一.抽象数据类型（ADT）

### 1.数组

#### (1)特点

- 拥有index索引；

- 高效查询；
- 低效结构更改；

### 2.链表

#### (1)特点

- 低效查询；
- 高效结构更改；

## 3.栈

#### (1)特点

- 先进先出；

## 4.队列

#### (1)特点

- 先进后出；

## 二.树

### 1.基础知识

#### (1) 结构概念

- 树是由一个根节点与0个或多个子树结合而成；
- 每个子树为根r的儿子；
- 子树中每棵的根都被来自根r的一条有向边所连接；
- 一棵树是由N个节点与N-1条边组成；
- 没有儿子的节点为树叶；
