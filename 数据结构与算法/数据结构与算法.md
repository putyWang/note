

# 第一章 基础知识

## 一. 数学基础知识

### 1. 级数

#### (1) $$i^k$$的级数

- 使用归纳法证明
  - 基准情形：确定定理对于一小部分（如$$i=1$$时）是正确的；
  - 归纳假设：扩展到如$$i=n$$时适用；
- 定理一

$$
\sum_{i=0}^N i = \frac{(N(N+1))}{2} \approx \frac{N^2}{2}
$$

- 定理二

$$
\sum_{i=0}^N i^2 = \frac{(N(N+1)(2N+1))}{3} \approx \frac{N^3}{3}
$$

- 定理三

$$
\sum_{i=0}^N i^k \approx \frac{N^{k+1}}{|k+1|}
$$

#### (2) 调和数（$$H_n$$）

- 当上述公式中$$k=-1$$时，最后一个公式由于$$k+1=0$$导致该式子无法成立；

- 这时就可以使用调和数Hn来表示该式的结果；
  $$
  H_N = \sum_{i=1}^N \frac{1}{i} \approx log_eN
  $$

- 上述近似式的误差趋向于$$\gamma \approx 0.57721566$$ ，称为欧拉常数。

#### (3) 级数运算

$$
\sum_{i=1}^N f(N) = Nf(N)
$$

$$
\sum_{i=n_0}^N f(i) = \sum_{i=1}^N f(i) - \sum_{i=1}^{n_0 - 1} f(i)
$$

### 2. 递归

#### (1) 定义

- 递归就是函数用自己来定义；
- 递归并不是一个循环推理（circular logic）；
  - 循环推理：使用$$f(5)$$来得到$$f(5)$$这样的运算就是循环推理；
  - 递归：递归通常采用$$f(4)$$来得到$$f(5)$$这样的形式；

#### (2) 四大准则

- 基准情形：就是无需递归就可得出的某些基本情形，就是递归最终要达到的停止情形，每个递归必须拥有基准情形；
- 不断推进：对于需要递归求解的情形，需要在每次递归之中不断向基准情形靠近；
- 设计法则：所有的递归应该都是可以正常运行；
- 合成效益法则：对同一实例进行处理时，切勿在不同递归调用中做重复性工作；

### 3. 算法分析基础

#### (1) 四大定义

- 如果存在正常c和$$n_o$$，使得当$$N\geqq n_o$$时$$T(N)\leqq cf(n_o)$$，则记为$$T(N)= O(f(N))$$;

- 如果存在正常c和$$n_o$$，使得当$$N\geqq n_o$$时$$T(N)\geqq cg(n_o)$$，则记为$$T(N)= \Omega(f(N))$$;

- 当且仅当$$T(N)= O(f(N))$$和$$T(N)= \Omega(f(N))$$，则$$T(N)= \Theta(h(N))$$;

- 如果存在正常c和$$n_o$$，使得当$$N> n_o$$时$$T(N)< cp(n_o)$$，则记为$$T(N)= o(f(N))$$，有时也可以说，如果$$T(N)= O(f(N))$$且$$T(N)\neq \Theta(h(N))$$，则记为$$T(N)= o(f(N))$$;

#### (2) 法则

- 如果$$T_1(N)= O(f(N))$$和$$T_2(N)= O(g(N))$$; 
  - $$T_1(N) + T_2(N)= O(f(N) + g(N))$$（直观可以写成$$max(O(f(N)), O(g(N)))$$;
  - $$T_1(N) * T_2(N)= O(f(N) * g(N))$$;
- 如果$$T(N)$$是一个k次多项式，则$$T(N)= \Theta(h(N))$$;
- 对任意常数k，$$log^k N = O(N)$$；
- 典型增长率

|    函数     | 名称       |
| :---------: | ---------- |
|      c      | 常数       |
|  $$log N$$  | 常数       |
| $$log^2 N$$ | 对数平方的 |
|      N      | 线性的     |
| $$Nlog N$$  |            |
|   $$N^2$$   | 二次的     |
|   $$N^3$$   | 三次的     |
|   $$2^N$$   | 指数的     |

### 4. 模运算

#### (1) 概念

- 如果$$N$$能够整除$$A-B$$，那么就说$$A$$与$$B$$模$$N$$同余，记为$$A \equiv B (mod \quad N)$$；

#### (1) 基本运算

- 若$$A \equiv B(mod \quad N)$$，则$$A+C \equiv B + C（mod \quad N）$$和$$AD \equiv BD（mod \quad N）$$；

## 二. java基础知识

### 1. 泛型

#### (1) 泛型机制

- 在除去基本类型以外，实现的方法是相同的，就可以使用泛型机制实现这种功能；

- 泛型机制就是用来描述这种基本功能的机制；

- java中使用Object类实现泛型机制；

- 协变数值类型：java类型应该不是类型兼容，但在java数组中却是类型兼容的；

- 在声明类时使用菱形运算符（<>）实现泛型；

  ```java
  /**
  *设置泛型
  */
  class IntStore<T extends Object>{
      //定义泛型对象
      private T[] max;
  
      public T[] getMax() {
          return max;
      }
  
      public void setMax(T[] max) {
          this.max = max;
      }
  }
  ```

#### (2) 基本类型的包装

- 包装类是用来存储基本类的类型，并添加一些基本类不能支持或不能正确支持的操作；
- java中的包装类的包装对象是不可变的（状态是不可变的），存储对象构建时所设置原值，并提供方法获取该原值；
- 自动装箱：将一个基本数据类型的值赋予给包装类型时自动调用包装类型的构造方法将数值赋予包装类型；
- 自动拆箱：将一个基本数据类型的值赋予给包装类型时自动调用包装类型的取值方法（java1.5之前Integer类中的intValue()方法）获取包装类型中的数值；

#### (3) 通配符

- 通配符用来表示参数类型的子类（或者超类）；

- 使用IntStore<? extends Integer>表示；

  ```java
      static void printInteger(IntStore<? extends Integer> s){
          for (int i = 0; i < s.getMax().length; i++) {
              System.out.print(s.getMax()[i] + " ");
          }
      }
  ```

#### (4) 泛型static方法

- 用于定义static所有要使用的特定类型，放在static之后；

- 可以用于定义特定的返回值类型；

- 可以用于声明一个局部变量；

- 可以用于多于一个的参数类型中；

  ```java
  static<T extends Integer> T findMax(IntStore<T> s){
      T max = s.getMax()[0];
      for (T i : s.getMax()) {
          if(max.compareTo(i) == -1)
              max = i;
      }
      return max;
  }
  ```

#### (5) 类型擦除

- 在虚拟机类编译过程中，将泛型类转换为非泛型类；
- 原始类：编译器通过类型擦除，生成与泛型类同名的原始类；
- 类型擦除生成的代码与本身的代码没有区别，不能提升程序运行速度；
- 优点：编译器进行类型检验，而不是程序员自己进行类型转换；

#### (6) 泛型使用的限制

- 基本数据类型不能作为类型参数，只能使用包装类型；
- instanceOf检测和类型转换工作只对原始类型进行；
- 泛型类中static方法和static域均不可引用类的类型变量；
- 不能创建一个泛型类型的实例或者泛型数组对象；
- 不能对参数化类型的数组进行实例化；

### 2. 函数对象（function object)

- 该类是一个没有数据只有一个方法的类；
- 将泛型对象放在方法内部进行传递；

## 三. 运行时间分析

### 1. 一般法则

#### (1) for循环

- for循环的运行时间至多是该for循环内部哪些语句的运行时间乘以迭代次数；

#### (2) 嵌套for循环

- 从里向外顺序分析循环；
- 在一组嵌套循环内部的一条语句总的运行时间为该语句的运行时间乘以改组中所有的for循环的大小和乘积；

#### (3) 顺序语句

- 将各个语句的运行时间求和即可；

#### (4) if/else语句

- 一个if/else语句的运行时间不超过判断的运行时间加上，判断内容最长的运行时间；

### 2. 运行时间的对数

#### (1) 折半查找

#### (2) 欧几里得算法

- 计算公约数的欧几里得算法

```java
public static long gcd(long m, long n){
    while (n != 0){
        long rem = m % n;
        m = n;
        n = rem;
    }
    
    return m;
}
```

- 定理
  - 如果$$M>N$$，则$$M mod N < M/2$$;

#### (3) 幂运算

```java
public static long pow(long x, int n){
    if (n == 0)
        
        return 1;
    if (n == 1)
        return x;
    
    if (n % 2 == 0)
        
        return pow (x * x, n/2);
    else
        
        return pow (x * x, n/2) * x;
    
}
```

# 第二章  基本数据结构

## 一. 抽象数据类型（ADT）

- 数组：数组特点拥有index索引、高效查询及低效结构更改；

- 链表：低效查询、高效结构更改；

- 栈：先进先出；

- 队列：先进后出；

## 二. 树

### 1. 基础知识

#### (1) 结构概念

- 树是由一个根节点与0个或多个子树结合而成；
- 每个子树为根r的儿子；
- 子树中每棵的根都被来自根r的一条有向边所连接；
- 一棵树是由N个节点与N-1条边组成；
- 没有儿子的节点为树叶；

#### (2) 树的遍历方式

- 前序遍历
  - 对节点的处理工作在它诸儿子节点处理顺序之前；
- 后序遍历
  - 对节点的处理工作在它诸儿子节点处理顺序之后；
  - 可以实现数学算式的后缀表达式；

### 2. 二叉树

#### (1) 主要性质

- 每个节点拥有不多于两个儿子节点的树；
- 平均二叉树的深度要比节点个数N小得多（平均深度为$$O(\sqrt{N})$$）；
- 二叉查找树深度平均值为（平均深度为$$O(logN)$$）；
- 摊还时间：当M次操作的序列总的最长运行时间为$$O(Mf(N))$$,则摊还时间为$$O(f(N))$$

#### (2) 二叉查找树

- 主要性质：

  - 树中每个节点左子树中所有值要小于节点值；

  - 树中每个节点右子树中所有值要大于节点值；

  - 内部路径长：一棵树的所有节点的深度和；

  - 一N节点树的内部路径长($$D(N)$$)的递推公式为：
    $$
    D(N)=D(i)+D(N-i-1)+N-1
    $$

    $$
    D(N)=\frac{2}{N}[\sum_{j=0}^N D(j)]+N+1
    $$

    - $$D(i)$$为i节点左子树；

    - $$D(N-i-1)$$为N-i-1节点右子树；

#### (3) 平衡二叉树

- 带有平衡条件的二叉查找树；
-  每个节点的左子树和右子树的高度最多差1(-1表示为null)的二叉查找树；
- 利用旋转来保持树的平衡：
  - 平衡是被外部节点插入破坏的情况使用单旋转；
  - 平衡是被内部节点插入破坏的情况使用双旋转；
- 摊还时间为$$O(N)$$；

#### (4) 伸展树

- 定义：当一个节点被访问后，随后通过一系列AVL树的旋转被推到根上；
- 伸展树可以有效保证摊还时间为$$O(logN)$$;
- 展开
  - 在节点为访问后，沿着访问路径实施旋转操作后将访问节点推到根节点的过程；
  - 之字形（zig-zag）:子与父与父与爷路径相反；
  - 一字型（zig-zig）:子与父与父与爷路径相同；
  - 采用两次与路径方向相同的旋转进行调整；
- 当访问深度不够时使用伸展树有可能会降低访问效率；

### 3. B树

#### (1) 基础

- 数据项存储在树叶中
- 非叶节点存储到$$M-1$$个关键字以指示搜索的方向，关键字i代表子树$$i+1$$中的最小关键字；
- 树的根或者是一片树叶，或者其儿子数在$$2\sim M$$之间;
- 除根外，所有非叶子节点的儿子书在$$[M/2]\sim M$$之间；
- 所有树叶都在相同的深度上并有$$[L/2]\sim L$$之间个数据项；
- 一颗M叉查找树可以有M路分支，一只完全M叉树的高度大约为$$log_M N$$;

#### (2) B树的操作

- 向满叶子节点中插入数据，插入后进行分裂，父节点满后分裂向上传递；
- 删除后不满一半的叶子节点时
  - 首先向邻居节点领养一个邻项来矫正；
  - 若旁边节点在借了节点后也少于一半的情况，直接将两个节点进行结合；

## 三. 散列

### 1. 经典散列函数

#### (1) 基本性质

- 关键字的返回值一般为$$key\quad mode\quad Tablesize$$;

- 为了使散列表空间有效使用，一般表的大小一般为素数；

- 装填因子（$$\lambda$$）为已经存储的元素数与表大小之比；

- java中使用的散列函数$$\sum_{i=0}^{KeySize-1}Key[KeySize-i-1]*31^i$$;

  ```java
  public static int hash(String key, int tableSize) {
      int hashVal = 0;
      
      for (int i = 0; i < ket.length(); i++) {
          hashVal = 37 * hashVal + key.chartAt(i);
      }
      
      hashVal %= tableSize;
      if (hashVal < 0) {
          hashVal += tableSize;
      }
      
      return hashVal;
  }
  ```

#### (2) 分离链接法

- 将散列到同一个值的所有元素保留到同一个表中；
- 在java中hashMap使用的就是该方法，在每项中维护一个链表用来存储hash值重复的元素；
- 一次查找中，最不利情况下需要遍历$$1+(\lambda/2)$$条链；
- 在该方式中一般维持$$\lambda$$值为1左右，即预期插入数据数与表大小差距不大；

#### (3) 探测散列表（不使用链表的散列表）

- 基本性质

  - 函数的表达式
    $$
    h_i(x)=(hash(x)+f(i)) \quad mod \quad tableSize
    $$

  - 不使用分离链接法的散列表装填因子应该低于$$\lambda =0.5$$;
  - 再散列：随着散列表数据的增加，当$$\lambda$$大于等于临界值时对原有散列表进行扩容的操作；
    - 第一种方式：表满到一半直接再散列；
    - 第二种方式：插入失败进行再散列；
    - 第三种方式：途中策略（最具有优势的方式 ）；

- 线性探测法
  - $$f(x)$$函数的表达式$$f(i)=i$$;
  - 一次聚集：当表较空时，由于插入间隔为1，插入数据处聚集大量数据的现象；
  - 插入与最差查找的预期探测次数为$$\frac{1}{2}(1+\frac{1}{(1-\lambda)^2})$$;
  - 查找的最优探测次数为$$\frac{1}{2}(1+\frac{1}{(1-\lambda)})$$;
  
- 平方探测法
  - $$f(x)$$函数的表达式$$f(i)=i^2$$;
  - 当表大小为素数，且$$\lambda \leqq0.5$$时，总能向表中插入新元素；
  - 若表填充位置仅仅比一半多一个，也有可能导致插入失败；
  - 优势：避免了一次聚集；
  - 二次聚集：表示在插入数hash值相同时，他们将探测同一单元的现象；

- 双散列
  - $$f(x)$$函数的表达式$$f(i)=i*hash_2(x)$$;
  - 其中$$hash_2(x)$$可以采用$$R-(x \quad mod \quad R)$$这样的式子进行计算（R为小于tableSize的素数）;

#### (4) 完美散列

- 当知道需要插入的数据数量，确定一个散列算法与tableSize，使得可以一次性插入所有数据；
- 定理1：若N个球被放入$$M=N^2$$个盒子之中，则所有盒子中球的数量均不超过1的概率不小于$$1/2$$;
- 定理2：若N个项被放入包含N个盒子的主散列表中，则要保证所有盒子中球的数量均不超过1的概率不小于$$1/2$$需要的二级散列表总容量为2N；

### 2. 新式散列函数

#### (1) 布谷鸟散列

- 维护多张半满表，分别用不同的散列算法对两张表进行计算；
- 每个数据插入时会直接插入第一张表，然后原有数据直接插入第二张表，第二张表中数据又插入第一张表，依次内推，直到数据完全插入表中；
- 表的装填因子小于0.5时，产生插入循环的概率非常低；
- 表的装填因子小于0.5时，成功插入需要超过$$O(logN)$$次数的概率时极低的;
- 在查找时可以通过，多表并行的方式进行查找；
- 在布谷鸟散列中插入方法的实现中
  - 使用随机方式进行替换；
  - 第一项、最后一项及按序列替换插入效率要低于随机替换；
- 使用两个分开的表的经典布谷鸟散列期望值上界大概为$$1/(1-(4\lambda^2)^{1/3})$$;
- 且越接近1/2越差，因此最大填充因子可以选择小一点（0.4）或者选择多于两个的散列函数；

#### (2) 跳房子散列

- 线性探测算法的改善；
- 维护一个探索最大探索序列的上界（MAX_DIST）来保证探索为常数时间；

#### (3) 通用散列法

- 满足条件
  - 散列函数计算时间必须为常数；
  - 散列函数各项在数组中的分布是均匀的；
- 定义
  - M表示tableSize；  
  - 如果对任意的$$x \ne y$$，散列函数族$$H$$中有$$H(x)=h(y)$$的散列函数h的个数至多为$$|H|/M$$，则一个散列函数族H是通用的；
  - 如果对任意的$$x_1 \ne y_1$$，$$x_2 \ne y_2$$，$$x_3 \ne y_3$$，$$x_k \ne y_k$$，$$H$$中有$$H(x_1)=h(y_1)$$，$$H(x_2)=h(y_2)$$，$$H(x_3)=h(y_3)$$，$$H(x_k)=h(y_k)$$的散列函数h的个数至多为$$|H|/M^k$$，则一个散列函数族$$H$$是$$k-$$通用的；
  - 散列族$$H=$${$$H_{a,b}(x)=((ax+b)\quad mod\quad p)\quad mod \quad M$$，其中$$1\leqq a\leqq {p - 1}$$，$$1\leqq b\leqq {p - 1}$$}成立； 
  - 梅森素数：
    - 使用位移运算与一次减法完成的素数，如：$$2^{31} - 1$$，$$2^{5} - 1$$等；
    - 一次对梅森素数取模的操作可以使用位移运算和一次加法完成；

## 四. 优先队列（堆）

### 1.  二叉堆

#### (1). 结构性质

- 一颗被完全填满的二叉树（完全二叉树）；
- 新加入的元素从叶子节点从左到右依次填入；
- 高为h的完全二叉树有$$2^h$$到$$2^{h+1} - 1$$个节点；
- 使用数组实现的完全二叉树
  - 任意位置$$i$$上的元素，左儿子在$$2i$$，右儿子在$$2i+1$$；
  - 父节点的位置为$$\lfloor i/2 \rfloor$$;

#### (2). 堆序性质

- 让操作快速执行的性质；
- 最小值应该在根上；
- 在一个堆中，对于每一个节点$$X$$，$$X$$的父亲中的关键字小于（或等于）$$X$$中的关键字，根节点除外；

#### (3). 定理

- 包含$$2^{h+1}-1$$个节点、高为h的理想二叉树的节点高度和为$$2^{h+1}-1-(h+1)$$;

### 2. d-堆

- 大致上与二叉堆一致，唯一的不同就是每个节点有d个子节点；
- 插入数据的时间复杂度低于二叉堆（$$O(log_d(N))$$）；
- 删除最小值的时间复杂度高于二叉堆（$$O(dlog_d(N))$$）；
- 由于实际操作中，插入数据的次数要远远多余删除最小数据的次数，因此d-堆效率是要高于二叉堆的；

### 3. 左式堆（leftist heap）

#### (1). 定义

- 能有效支持合并操作（使用链表）；
- 与二叉堆相同，都具有结构性和有序性；
- 零路径长（null path）：
  - 从节点到一个不具有两个儿子节点的最短距离；
  - 具有一个儿子或者没有儿子的节点的零路径长为0；
  - 每个节点的零路径为它儿子节点的零路径最小值+1；
  - 空节点的零路径为-1；
- 左式堆中，左儿子的零路径长不小于右儿子；
- 在右路径上右r个节点的左式堆必然至少由$$2^r - 1$$个节点；

### 4. 斜堆

- 左式堆的自调节形式；
- 斜堆是具有堆序的二叉树，但不存在对树的结构的限制；
- 所有操作的运行时间最长为$$O(N)$$；
- 与伸展树一样，连续操作M次运行的最长时间为$$O(Mlog(N))$$；
- 在斜堆合并过程中，除右节点最大值除外，都需要交换他的左右节点；

### 5. 二项队列

#### (1). 结构

- 二项队列不是一颗堆序的树，而是堆序树的结合，称为森林；
- 其中每棵树都具有一定的约束，叫做二项树；
  - 每个高度上至少存在一颗二项树；
  - 高度为0的二项树是一颗单节点树；
  - 高度为k的二项树$$B_k$$通过将一颗二项树$$B_{k-1}$$附在另一二项树$$B_{k-1}$$的根上构成的；
  - 二项树$$B_k$$由一个带有儿子的$$B_0$$，$$B_1$$，$$B_2$$，. . .，$$B_{k-1}$$的根组成；
  - 高度为k的二项树恰好有$$2^k$$个节点；
  - 将堆序施加到二项树上并允许任意高度上最多一颗二项树，那么可以使用二项树的集合表示任意大小的优先队列；
  - 可以使用二进制数表示优先队列，如大小为13的优先队列可以表示为1101（其中有$$B_3$$，$$B_2$$，$$B_0$$）；

#### (2). 二项队列操作 

- 最小元查找可以通过搜索所有的树的根来找出，由于最多有$$logN$$颗不同的树，因此查找最小值时间为$$O(logN)$$;
- 合并操作基本上是通过将两个队列加到一起来完成的，合并其中相同的项（$$O(logN)$$操作时间）；
- deleteMin可以通过找出一颗具有最小根的二项树来完成；
- 

### 6. 优先队列的使用

#### (1). 选择问题

- 问题描述：确定一组数中的第k个最大者；
- 采用堆排序的方式解答该问题$$Nlog(N)$$；
- 采用拥有k个元素的堆进行处理$$Nlog(N)$$；

#### (2). 事件模拟

- 使用一份单位时间量（滴答tick），来代替一天中准确的时间；
- 每走过一个单位时间量，对其中的所有事件进行处理；
- 最后在所有顾客走光与所有出纳员都空闲时结束模拟；

# 第三章. 算法

## 一. 排序

### (1). 基础

#### 1. 简单排序算法的下界

- 逆序(inversion)：具有$$i<j$$但$$a[i]>a[j]$$性质的序偶$$(a[i],a[j])$$的数组叫做逆序;
- 定理：
  - $$N$$个互异数组成的数组其平均逆序数为$$N(N-1)/4$$；
  - 通过交换相邻元素进行排序的任何算法平均都需要$$\Omega(N^2)$$；

### (2). 插入排序

#### 1. 算法

- 插入排序是由$$N-1$$趟排序组成；

- 由$$p=1$$到$$N-1$$趟，插入排序保证从位置0到位置p上的元素已处于排序状态；

  ```java
  public static <T extends Comparable<? super T>> void insertionSort (T[] array) {
      if (array == null ||array.length <= 1) {
          return;
      }
      
      T temp;
      
      for (int i = 0; i < array.length - 1; i ++) {
          
          for (int j = i + 1; j < array.length; j++) {
              if (array[j].compareto(array[i]) {
                  temp = array[i];
                  array[i] = array[j];
                  array[j] = temp;
              }
          }
      }
  }
  ```

#### 2. 插入排序的分析

- 嵌套训话的每一个都花费N次迭代，插入排序为$$O(N^2)$$；
- 当输入数组预先排序好时使用时间为$$O(N)$$；
- 插入排序过程中进行逆序数次交换；
- 总的排序允许时间为$$O(I+N)$$，其中$$I$$为数组逆序数，N为数组长度；

$$
\sum_{i =2}^{N} = 2 +3 +4 + ... + N =\frac{(N+2)(N-1)}{2}=\frac{N^2+N-2}{2}=\Theta(N^2)
$$

### (3). 希尔排序

#### 1. 定义

- 希尔排序通过比较相距一定间隔的元素来工作，各趟比较作用的距离随着算法的进行而减小，直到只比较相邻元素的最后一趟排序为止；
- 希尔排序有时也可以叫做缩减增量排序；
- 增量序列（increment sequence）：具有$$h_1=1$$的任意单增互斥数组（一般做法时数据间隔为1）；
  - 希尔排序使用增量序列中$$h_k$$进行排序后，对于任意$$i$$都有$$a[i]\geqq a[i+h_k]$$，现数组称为是$$h_k$$排序的（$$h_k$$-sorted）；
  - 一个$$h_k$$排序的数组，在进行后续排序（$$h_{k-1}$$排序）时会保持他的排序性；

#### 2. shell序列的希尔排序实现

- 流行的shell建议的序列（不是很好）：$$h_t=\lfloor N/2 \rfloor$$和$$h_k=\lfloor h_{k+1}/2 \rfloor$$；

- 使用shell序列的希尔排序最坏情形的运行时间为$$\Theta (N^2)$$；

  ```java
  public static <T extends Comparable<? super T>> void shellSort (T[] array) {
      if (array == null ||array.length <= 1) {
          return;
      }
      
      T temp;
      int j;
      
      for (int h = array.length / 2; h > 0; h /= 2) {
      	
      	for (int i = h; i < array.length; i ++) {
      		temp = array[i]
      		
       		for (j = i; j >= h && temp.compareTo(a[j - h] < 0; j -= h)) {
       			array[j] = a[j - h];
       		}
              
              a [j] = temp; 
          }	
      }
  }
  ```

#### 3. hibbard序列的希尔排序实现

- hibbard增量序列：$$h_k = 2^k - 1$$;
- 使用hibbard增量的希尔排序的最坏情形的运行时间为$$\Theta (N^{3/2})$$；

### (4). 堆排序

#### 1. 基础

- 为了避免在二叉堆中使用多个数组，可以使用位于堆中最后的单元用来存放刚deleteMin删除的元素；
- 定理
  - 对N个互异项的随机排列进行堆排序所用比较的平均次数为$$2NlogN-O(NloglogN)$$；

#### 2. 实现

```java
/**
* 节点向下推函数
*/
private static void perDown() {

    T temp;
    int child;
    int i = 1;

    for (temp = array[i]; leftChild(i) < currentSize; i = child) {
        child = leftChild(i);

        if (child != currentSize - 1 && array[child].compareTo(array[child + 1]) < 0) {

            child ++;
        } if ( temp.compareTo(array[child]) < 0) {

            array[i] = array[child];
        } else
            break;
    }

    array[i] = temp;

}
```

### (5). 归并排序

#### 1. 基础

- 归并排序以$$O(NlogN)$$的最差情况运行；
- 归并排序是基本操作是合并两个已排序的表；
- 使用分治策略将数组分成若干份，然后进行合成；
- 使用递归策略进行合并；
- 在排序过程之中，会使用到线性附加内存；
- 与其余运行时间为$$O(NlogN)$$的排序方法相比，归并排序的运行时间严重依赖于比较元素和在数组中移动元素的相对开销（越大越不利）；

#### 2. 实现

```java
	/**
	* 主函数
	*/
	public static<T extends Comparable<? super T>> 
    void mergeSort (T[] a1, T[] tempArray, int left, int right) {
        
        if (left < right) {
            int center = (left + right) / 2;
            mergeSort(a1, tempArray, left, center);
            mergeSort(a1, tempArray, center + 1, right);
            merge(a1, tempArray, left, center + 1, right);
        }
    }
    
	/**
	* 合并前后有序数组
	*/
    private static <T extends Comparable<? super T>>
    void merge (T[] a, T[] tempArray, int leftPos, int rightPos, int rightEnd) {
        int leftEnd = rightPos - 1;
        int tmpPos = leftPos;
        //数组总长度
        int numElements = rightEnd - leftPos + 1;
        
        while (leftPos <= leftEnd && rightPos <= rightEnd) {
            
            if (a[leftPos].compareTo(a[rightPos]) < 0) {
                tempArray[tmpPos ++] = a[leftPos ++];
            } else {
                tempArray[tmpPos ++] = a[rightPos ++];
            }
        }
            
        while (leftPos <= leftEnd) {
            tempArray[tmpPos ++] = a[leftPos ++];
        }

        while (rightPos <= rightEnd) {
            tempArray[tmpPos ++] = a[rightPos ++];
        }

        for (int i = 0; i < numElements; i ++, rightEnd --) {
            a[rightEnd] = tempArray[rightEnd];
        }
    }
```

### (6). 快速排序

#### 1. 基础知识

- 快速排序算法使用非常精练和高度优化的内部循环；
- 运行时间最差为$$O(N^2)$$，平均运行时间为$$O(NlogN)$$；
- 与归并排序一样，也是一种分治的递归算法；
- 由于对于数据量较小的数组（<20）来说，快速排序不如插入排序，因此在数组大小被分割到足够小（10）时使用插入排序来提高效率；

#### 2. 实现

- 如果S中元素为0或者1，直接返回；

- 随便选取一项S，称之为枢纽元；

- 剩下元素分为两个不相关的集合，前一个集合的所有元素都小于枢纽元，后一个集合的所有元素都大于枢纽元；

- 对不相交集合分别递归使用该算法；

  ```java
     /**
       * 快速排序的实现
       * @param a
       * @param <T>
       */
      public static <T extends Comparable<? super T>>
      void quicksort(T[] a) {
          quicksort(a, 0, a.length - 1);
      }
  
      /**
       * 快速排序的实现
       * @param a
       * @param left
       * @param right
       * @param <T>
       */
      public static <T extends Comparable<? super T>>
      void quicksort(T[] a, int left, int right) {
          if (left + CUTOFF < right) {
              T media = median3(a, left, right);
  
              int start = left;
              int end = right - 1;
  			
              //速度快的核心
              for (;;) {
                  
                  while (a[start ++].compareTo(media) <= 0) {}
                  while (a[end --].compareTo(media) >= 0) {}
                  
                  if (start < end) {
                      swap (a, start ++, end --); 
                  } else {
                      break;
                  }
              }
              
              swap (a, start, right - 1);
  
              quicksort(a, left, start - 1);
              quicksort(a, start + 1, right);
          }else {
              insertionSort(a, left, right);
          }
  
      }
  
      /**
       * 执行三数中值分割法选择最小值
       * @param a
       * @param left
       * @param right
       * @param <T>
       */
      private static <T extends Comparable<? super T>>
      T median3(T[] a, int left, int right) {
  
          int middle = (left + right) / 2;
  
          if (a[middle].compareTo(a[left]) < 0) {
              swap(a, left, middle);
          }
  
          if (a[right].compareTo(a[left]) < 0) {
              swap(a, left, right);
          }
  
          if (a[right].compareTo(a[middle]) < 0) {
              swap(a, middle, right);
          }
  
          //将枢纽元放置在right-1的位置上
          swap(a,middle,right -1);
  
          return a[right - 1];
      }
  
      /**
       * 交换两个数组中两位置的元素
       * @param a
       * @param left
       * @param right
       * @param <T>
       */
      private static <T extends Comparable<? super T>>
      void swap(T[] a, int left, int right) {
          T temp = a[left];
          a[left] = a[right];
          a[right] = temp;
      }
  ```

#### 3. 枢纽元的选取

- 将第一个元素作为枢纽元（最差情况）；
- 随机选取枢纽元是一种保险的方法；
- 三数中值分割法
  - 用来替换选取数组所有数中的中位数；
  - 使用随机三个数中的中值作为枢纽元；
  - 一般做法选择左端点，右端点及中间位置的三个数来进行分割数的计算；

#### 4. 分割策略

- 将选取的枢纽元与最后一个元素交换；
- 然后利用双指针将小于枢纽元的元素放在左边，大于枢枢纽元的元素放置在右边；
- 最后将大元素的右左端点与枢纽点交换；

### (7). 排序算法一般下界

#### 1. 决策树

- 决策树是用于证明下界的抽象概念；
- 决策树的构成
  - 算法初始状态为根节点（未进行比较）；
  - 每个节点表示元素之间可能的排序（与已经进行的比较一致）；
  - 比较结果为树的边；
  - 排序算法所使用的比较次数等于最深的树叶深度；
- 通过只使用比较的进行排序的每一种都算法都可以使用决策树来表示；
- 定理1：
  - 令T是深度为d的二叉树，则T最多有$$2^d$$片树叶；
  - 具有$$L$$片树叶的二叉树深度至少为$$\lceil log L \rceil$$;
  - 只使用元素间比较的任意排序算法在最坏情况下最少需要$$\lceil log (N!) \rceil$$次比较；
  - 只使用元素间比较的任何排序算法均需要$$\Omega(NlogN)$$次比较；
