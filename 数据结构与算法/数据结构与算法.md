# 第一章 基础知识

## 一.数学基础知识

### 1.级数

#### (1)$$i^k$$的级数

- 使用归纳法证明
  - 基准情形：确定定理对于一小部分（如$$i=1$$时）是正确的；
  - 归纳假设：扩展到如$$i=n$$时适用；
- 定理一

$$
\sum_{i=0}^N i = \frac{(N(N+1))}{2} \approx \frac{N^2}{2}
$$

- 定理二

$$
\sum_{i=0}^N i^2 = \frac{(N(N+1)(2N+1))}{3} \approx \frac{N^3}{3}
$$

- 定理三

$$
\sum_{i=0}^N i^k \approx \frac{N^{k+1}}{|k+1|}
$$

#### (2)调和数（$$H_n$$）

- 当上述公式中$$k=-1$$时，最后一个公式由于$$k+1=0$$导致该式子无法成立；

- 这时就可以使用调和数Hn来表示该式的结果；
  $$
  H_N = \sum_{i=1}^N \frac{1}{i} \approx log_eN
  $$

- 上述近似式的误差趋向于$$\gamma \approx 0.57721566$$ ，称为欧拉常数。

#### (3)级数运算

$$
\sum_{i=1}^N f(N) = Nf(N)
$$

$$
\sum_{i=n_0}^N f(i) = \sum_{i=1}^N f(i) - \sum_{i=1}^{n_0 - 1} f(i)
$$

### 2.递归

#### (1)定义

- 递归就是函数用自己来定义；
- 递归并不是一个循环推理（circular logic）；
  - 循环推理：使用$$f(5)$$来得到$$f(5)$$这样的运算就是循环推理；
  - 递归：递归通常采用$$f(4)$$来得到$$f(5)$$这样的形式；

#### (2)四大准则

- 基准情形：就是无需递归就可得出的某些基本情形，就是递归最终要达到的停止情形，每个递归必须拥有基准情形；
- 不断推进：对于需要递归求解的情形，需要在每次递归之中不断向基准情形靠近；
- 设计法则：所有的递归应该都是可以正常运行；
- 合成效益法则：对同一实例进行处理时，切勿在不同递归调用中做重复性工作；

### 3.算法分析基础

#### (1)四大定义

- 如果存在正常c和$$n_o$$，使得当$$N\geqq n_o$$时$$T(N)\leqq cf(n_o)$$，则记为$$T(N)= O(f(N))$$;

- 如果存在正常c和$$n_o$$，使得当$$N\geqq n_o$$时$$T(N)\geqq cg(n_o)$$，则记为$$T(N)= \Omega(f(N))$$;

- 当且仅当$$T(N)= O(f(N))$$和$$T(N)= \Omega(f(N))$$，则$$T(N)= \Theta(h(N))$$;

- 如果存在正常c和$$n_o$$，使得当$$N> n_o$$时$$T(N)< cp(n_o)$$，则记为$$T(N)= o(f(N))$$，有时也可以说，如果$$T(N)= O(f(N))$$且$$T(N)\neq \Theta(h(N))$$，则记为$$T(N)= o(f(N))$$;

#### (2)法则

- 如果$$T_1(N)= O(f(N))$$和$$T_2(N)= O(g(N))$$; 
  - $$T_1(N) + T_2(N)= O(f(N) + g(N))$$（直观可以写成$$max(O(f(N)), O(g(N)))$$;
  - $$T_1(N) * T_2(N)= O(f(N) * g(N))$$;
- 如果$$T(N)$$是一个k次多项式，则$$T(N)= \Theta(h(N))$$;
- 对任意常数k，$$log^k N = O(N)$$；
- 典型增长率

|    函数     | 名称       |
| :---------: | ---------- |
|      c      | 常数       |
|  $$log N$$  | 常数       |
| $$log^2 N$$ | 对数平方的 |
|      N      | 线性的     |
| $$Nlog N$$  |            |
|   $$N^2$$   | 二次的     |
|   $$N^3$$   | 三次的     |
|   $$2^N$$   | 指数的     |

## 二.java基础知识

### 1.泛型

#### (1)泛型机制

- 在除去基本类型以外，实现的方法是相同的，就可以使用泛型机制实现这种功能；

- 泛型机制就是用来描述这种基本功能的机制；

- java中使用Object类实现泛型机制；

- 协变数值类型：java类型应该不是类型兼容，但在java数组中却是类型兼容的；

- 在声明类时使用菱形运算符（<>）实现泛型；

  ```java
  /**
  *设置泛型
  */
  class IntStore<T extends Object>{
      //定义泛型对象
      private T[] max;
  
      public T[] getMax() {
          return max;
      }
  
      public void setMax(T[] max) {
          this.max = max;
      }
  }
  ```

#### (2)基本类型的包装

- 包装类是用来存储基本类的类型，并添加一些基本类不能支持或不能正确支持的操作；
- java中的包装类的包装对象是不可变的（状态是不可变的），存储对象构建时所设置原值，并提供方法获取该原值；
- 自动装箱：将一个基本数据类型的值赋予给包装类型时自动调用包装类型的构造方法将数值赋予包装类型；
- 自动拆箱：将一个基本数据类型的值赋予给包装类型时自动调用包装类型的取值方法（java1.5之前Integer类中的intValue()方法）获取包装类型中的数值；

#### (3)通配符

- 通配符用来表示参数类型的子类（或者超类）；

- 使用IntStore<? extends Integer>表示；

  ```java
      static void printInteger(IntStore<? extends Integer> s){
          for (int i = 0; i < s.getMax().length; i++) {
              System.out.print(s.getMax()[i] + " ");
          }
      }
  ```

#### (4)泛型static方法

- 用于定义static所有要使用的特定类型，放在static之后；

- 可以用于定义特定的返回值类型；

- 可以用于声明一个局部变量；

- 可以用于多于一个的参数类型中；

  ```java
  static<T extends Integer> T findMax(IntStore<T> s){
      T max = s.getMax()[0];
      for (T i : s.getMax()) {
          if(max.compareTo(i) == -1)
              max = i;
      }
      return max;
  }
  ```

#### (5)类型擦除

- 在虚拟机类编译过程中，将泛型类转换为非泛型类；
- 原始类：编译器通过类型擦除，生成与泛型类同名的原始类；
- 类型擦除生成的代码与本身的代码没有区别，不能提升程序运行速度；
- 优点：编译器进行类型检验，而不是程序员自己进行类型转换；

#### (6)泛型使用的限制

- 基本数据类型不能作为类型参数，只能使用包装类型；
- instanceOf检测和类型转换工作只对原始类型进行；
- 泛型类中static方法和static域均不可引用类的类型变量；
- 不能创建一个泛型类型的实例或者泛型数组对象；
- 不能对参数化类型的数组进行实例化；

### 2.函数对象（function object)

- 该类是一个没有数据只有一个方法的类；
- 将泛型对象放在方法内部进行传递；

## 三.运行时间分析

### 1.一般法则

#### (1)for循环

- for循环的运行时间至多是该for循环内部哪些语句的运行时间乘以迭代次数；

#### (2)嵌套for循环

- 从里向外顺序分析循环；
- 在一组嵌套循环内部的一条语句总的运行时间为该语句的运行时间乘以改组中所有的for循环的大小和乘积；

#### (3)顺序语句

- 将各个语句的运行时间求和即可；

#### (4)if/else语句

- 一个if/else语句的运行时间不超过判断的运行时间加上，判断内容最长的运行时间；

### 2.运行时间的对数

#### (1)折半查找

#### (2)欧几里得算法

- 计算公约数的欧几里得算法

```java
public static long gcd(long m, long n){
    while (n != 0){
        long rem = m % n;
        m = n;
        n = rem;
    }
    
    return m;
}
```

- 定理
  - 如果$$M>N$$，则$$M mod N < M/2$$;

#### (3)幂运算

```java
public static long pow(long x, int n){
    if (n == 0)
        
        return 1;
    if (n == 1)
        return x;
    
    if (n % 2 == 0)
        
        return pow (x * x, n/2);
    else
        
        return pow (x * x, n/2) * x;
    
}
```

# 第二章  基本数据结构

## 一.抽象数据类型（ADT）

### 1.数组

#### (1)特点

- 拥有index索引、高效查询及低效结构更改；

### 2.链表

#### (1)特点

- 低效查询、高效结构更改；

## 3.栈

#### (1)特点

- 先进先出；

## 4.队列

#### (1)特点

- 先进后出；

## 二.树

### 1.基础知识

#### (1) 结构概念

- 树是由一个根节点与0个或多个子树结合而成；
- 每个子树为根r的儿子；
- 子树中每棵的根都被来自根r的一条有向边所连接；
- 一棵树是由N个节点与N-1条边组成；
- 没有儿子的节点为树叶；

#### (2)树的遍历方式

- 前序遍历
  - 对节点的处理工作在它诸儿子节点处理顺序之前；
- 后序遍历
  - 对节点的处理工作在它诸儿子节点处理顺序之后；
  - 可以实现数学算式的后缀表达式；

### 2.二叉树

#### (1)主要性质

- 每个节点拥有不多于两个儿子节点的树；
- 平均二叉树的深度要比节点个数N小得多（平均深度为$$O(\sqrt{N})$$）；
- 二叉查找树深度平均值为（平均深度为$$O(logN)$$）；
- 摊还时间：当M次操作的序列总的最长运行时间为$$O(Mf(N))$$,则摊还时间为$$O(f(N))$$

#### (2)二叉查找树

- 主要性质：

  - 树中每个节点左子树中所有值要小于节点值；

  - 树中每个节点右子树中所有值要大于节点值；

  - 内部路径长：一棵树的所有节点的深度和；

  - 一N节点树的内部路径长($$D(N)$$)的递推公式为：
    $$
    D(N)=D(i)+D(N-i-1)+N-1
    $$

    $$
    D(N)=\frac{2}{N}[\sum_{j=0}^N D(j)]+N+1
    $$

    - D(i)$$为i节点左子树；

    - $$D(N-i-1)$$为N-i-1节点右子树；

#### (3)平衡二叉树

- 带有平衡条件的二叉查找树；
-  每个节点的左子树和右子树的高度最多差1(-1表示为null)的二叉查找树；
- 利用旋转来保持树的平衡：
  - 平衡是被外部节点插入破坏的情况使用单旋转；
  - 平衡是被内部节点插入破坏的情况使用双旋转；
- 摊还时间为$$O(N)$$；

#### (4)伸展树

- 定义：当一个节点被访问后，随后通过一系列AVL树的旋转被推到根上；
- 伸展树可以有效保证摊还时间为$$O(logN)$$;
- 展开
  - 在节点为访问后，沿着访问路径实施旋转操作后将访问节点推到根节点的过程；
  - 之字形（zig-zag）:子与父与父与爷路径相反；
  - 一字型（zig-zig）:子与父与父与爷路径相同；
  - 采用两次与路径方向相同的旋转进行调整；
- 当访问深度不够时使用伸展树有可能会降低访问效率；

### 3.B树

#### (1)基础

- 数据项存储在树叶中
- 非叶节点存储到$$M-1$$个关键字以指示搜索的方向，关键字i代表子树$$i+1$$中的最小关键字；
- 树的根或者是一片树叶，或者其儿子数在$$2\sim M$$之间;
- 除根外，所有非叶子节点的儿子书在$$[M/2]\sim M$$之间；
- 所有树叶都在相同的深度上并有$$[L/2]\sim L$$之间个数据项；
- 一颗M叉查找树可以有M路分支，一只完全M叉树的高度大约为$$log_M N$$;

#### (2)B树的操作

- 向满叶子节点中插入数据，插入后进行分裂，父节点满后分裂向上传递；
- 删除后不满一半的叶子节点时
  - 首先向邻居节点领养一个邻项来矫正；
  - 若旁边节点在借了节点后也少于一半的情况，直接将两个节点进行结合；

## 三.散列

### 1.散列函数

#### (1)基本性质

- 关键字的返回值一般为$$key\quad mode\quad Tablesize$$;

- 为了使散列表空间有效使用，一般表的大小一般为素数；

- 装填因子（$$\lambda$$）为已经存储的元素数与表大小之比；

- java中使用的散列函数$$\sum_{i=0}^{KeySize-1}Key[KeySize-i-1]*31^i$$;

  ```java
  public static int hash(String key, int tableSize) {
      int hashVal = 0;
      
      for (int i = 0; i < ket.length(); i++) {
          hashVal = 37 * hashVal + key.chartAt(i);
      }
      
      hashVal %= tableSize;
      if (hashVal < 0) {
          hashVal += tableSize;
      }
      
      return hashVal;
  }
  ```

#### (2)分离链接法

- 将散列到同一个值的所有元素保留到同一个表中；
- 在java中hashMap使用的就是该方法，在每项中维护一个链表用来存储hash值重复的元素；
- 一次查找中，最不利情况下需要遍历$$1+(\lambda/2)$$条链；
- 在该方式中一般维持$$\lambda$$值为1左右，即预期插入数据数与表大小差距不大；

#### (3)探测散列表（不使用链表的散列表）

- 基本性质

  - 函数的表达式
    $$
    h_i(x)=(hash(x)+f(i)) \quad mod \quad tableSize
    $$

  - 不使用分离链接法的散列表装填因子应该低于$$\lambda =0.5$$;
  - 再散列：随着散列表数据的增加，当$$\lambda$$大于等于临界值时对原有散列表进行扩容的操作；
    - 第一种方式：表满到一半直接再散列；
    - 第二种方式：插入失败进行再散列；
    - 第三种方式：途中策略（最具有优势的方式 ）；

- 线性探测法
  - $$f(x)$$函数的表达式$$f(i)=i$$;
  - 一次聚集：当表较空时，由于插入间隔为1，插入数据处聚集大量数据的现象；
  - 插入与最差查找的预期探测次数为$$\frac{1}{2}(1+\frac{1}{(1-\lambda)^2})$$;
  - 查找的最优探测次数为$$\frac{1}{2}(1+\frac{1}{(1-\lambda)})$$;
- 平方探测法
  - $$f(x)$$函数的表达式$$f(i)=i^2$$;
  - 当表大小为素数，且$$\lambda \leqq0.5$$时，总能向表中插入新元素；
  - 若表填充位置仅仅比一半多一个，也有可能导致插入失败；
  - 优势：避免了一次聚集；
  - 二次聚集：表示在插入数hash值相同时，他们将探测同一单元的现象；

- 双散列
  - $$f(x)$$函数的表达式$$f(i)=i*hash_2(x)$$;
  - 其中$$hash_2(x)$$可以采用$$R-(x \quad mod \quad R)$$这样的式子进行计算（R为小于tableSize的素数）;
  - 
