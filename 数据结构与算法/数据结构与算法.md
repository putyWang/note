
# 第一章 基础知识

## 一. 数学基础知识

### 1. 级数

#### (1) $$i^k$$的级数

- 使用归纳法证明
  - 基准情形：确定定理对于一小部分（如$$i=1$$时）是正确的；
  - 归纳假设：扩展到如$$i=n$$时适用；
- 定理一

$$
\sum_{i=0}^N i = \frac{(N(N+1))}{2} \approx \frac{N^2}{2}
$$

- 定理二

$$
\sum_{i=0}^N i^2 = \frac{(N(N+1)(2N+1))}{3} \approx \frac{N^3}{3}
$$

- 定理三

$$
\sum_{i=0}^N i^k \approx \frac{N^{k+1}}{|k+1|}
$$

#### (2) 调和数（$$H_n$$）

- 当上述公式中$$k=-1$$时，最后一个公式由于$$k+1=0$$导致该式子无法成立；

- 这时就可以使用调和数Hn来表示该式的结果；
  $$
  H_N = \sum_{i=1}^N \frac{1}{i} \approx log_eN
  $$

- 上述近似式的误差趋向于$$\gamma \approx 0.57721566$$ ，称为欧拉常数。

#### (3) 级数运算

$$
\sum_{i=1}^N f(N) = Nf(N)
$$

$$
\sum_{i=n_0}^N f(i) = \sum_{i=1}^N f(i) - \sum_{i=1}^{n_0 - 1} f(i)
$$

### 2. 递归

#### (1) 定义

- 递归就是函数用自己来定义；
- 递归并不是一个循环推理（circular logic）；
  - 循环推理：使用$$f(5)$$来得到$$f(5)$$这样的运算就是循环推理；
  - 递归：递归通常采用$$f(4)$$来得到$$f(5)$$这样的形式；

#### (2) 四大准则

- 基准情形：就是无需递归就可得出的某些基本情形，就是递归最终要达到的停止情形，每个递归必须拥有基准情形；
- 不断推进：对于需要递归求解的情形，需要在每次递归之中不断向基准情形靠近；
- 设计法则：所有的递归应该都是可以正常运行；
- 合成效益法则：对同一实例进行处理时，切勿在不同递归调用中做重复性工作；

### 3. 算法分析基础

#### (1) 四大定义

- 如果存在正常c和$$n_o$$，使得当$$N\geqq n_o$$时$$T(N)\leqq cf(n_o)$$，则记为$$T(N)= O(f(N))$$;

- 如果存在正常c和$$n_o$$，使得当$$N\geqq n_o$$时$$T(N)\geqq cg(n_o)$$，则记为$$T(N)= \Omega(f(N))$$;

- 当且仅当$$T(N)= O(f(N))$$和$$T(N)= \Omega(f(N))$$，则$$T(N)= \Theta(h(N))$$;

- 如果存在正常c和$$n_o$$，使得当$$N> n_o$$时$$T(N)< cp(n_o)$$，则记为$$T(N)= o(f(N))$$，有时也可以说，如果$$T(N)= O(f(N))$$且$$T(N)\neq \Theta(h(N))$$，则记为$$T(N)= o(f(N))$$;

#### (2) 法则

- 如果$$T_1(N)= O(f(N))$$和$$T_2(N)= O(g(N))$$; 
  - $$T_1(N) + T_2(N)= O(f(N) + g(N))$$（直观可以写成$$max(O(f(N)), O(g(N)))$$;
  - $$T_1(N) * T_2(N)= O(f(N) * g(N))$$;
- 如果$$T(N)$$是一个k次多项式，则$$T(N)= \Theta(h(N))$$;
- 对任意常数k，$$log^k N = O(N)$$；
- 典型增长率

|    函数     | 名称       |
| :---------: | ---------- |
|      c      | 常数       |
|  $$log N$$  | 常数       |
| $$log^2 N$$ | 对数平方的 |
|      N      | 线性的     |
| $$Nlog N$$  |            |
|   $$N^2$$   | 二次的     |
|   $$N^3$$   | 三次的     |
|   $$2^N$$   | 指数的     |

### 4. 模运算

#### (1) 概念

- 如果$$N$$能够整除$$A-B$$，那么就说$$A$$与$$B$$模$$N$$同余，记为$$A \equiv B (mod \quad N)$$；

#### (1) 基本运算

- 若$$A \equiv B(mod \quad N)$$，则$$A+C \equiv B + C（mod \quad N）$$和$$AD \equiv BD（mod \quad N）$$；

## 二. java基础知识

### 1. 泛型

#### (1) 泛型机制

- 在除去基本类型以外，实现的方法是相同的，就可以使用泛型机制实现这种功能；

- 泛型机制就是用来描述这种基本功能的机制；

- java中使用Object类实现泛型机制；

- 协变数值类型：java类型应该不是类型兼容，但在java数组中却是类型兼容的；

- 在声明类时使用菱形运算符（<>）实现泛型；

  ```java
  /**
  *设置泛型
  */
  class IntStore<T extends Object>{
      //定义泛型对象
      private T[] max;
  
      public T[] getMax() {
          return max;
      }
  
      public void setMax(T[] max) {
          this.max = max;
      }
  }
  ```

#### (2) 基本类型的包装

- 包装类是用来存储基本类的类型，并添加一些基本类不能支持或不能正确支持的操作；
- java中的包装类的包装对象是不可变的（状态是不可变的），存储对象构建时所设置原值，并提供方法获取该原值；
- 自动装箱：将一个基本数据类型的值赋予给包装类型时自动调用包装类型的构造方法将数值赋予包装类型；
- 自动拆箱：将一个基本数据类型的值赋予给包装类型时自动调用包装类型的取值方法（java1.5之前Integer类中的intValue()方法）获取包装类型中的数值；

#### (3) 通配符

- 通配符用来表示参数类型的子类（或者超类）；

- 使用IntStore<? extends Integer>表示；

  ```java
      static void printInteger(IntStore<? extends Integer> s){
          for (int i = 0; i < s.getMax().length; i++) {
              System.out.print(s.getMax()[i] + " ");
          }
      }
  ```

#### (4) 泛型static方法

- 用于定义static所有要使用的特定类型，放在static之后；

- 可以用于定义特定的返回值类型；

- 可以用于声明一个局部变量；

- 可以用于多于一个的参数类型中；

  ```java
  static<T extends Integer> T findMax(IntStore<T> s){
      T max = s.getMax()[0];
      for (T i : s.getMax()) {
          if(max.compareTo(i) == -1)
              max = i;
      }
      return max;
  }
  ```

#### (5) 类型擦除

- 在虚拟机类编译过程中，将泛型类转换为非泛型类；
- 原始类：编译器通过类型擦除，生成与泛型类同名的原始类；
- 类型擦除生成的代码与本身的代码没有区别，不能提升程序运行速度；
- 优点：编译器进行类型检验，而不是程序员自己进行类型转换；

#### (6) 泛型使用的限制

- 基本数据类型不能作为类型参数，只能使用包装类型；
- instanceOf检测和类型转换工作只对原始类型进行；
- 泛型类中static方法和static域均不可引用类的类型变量；
- 不能创建一个泛型类型的实例或者泛型数组对象；
- 不能对参数化类型的数组进行实例化；

### 2. 函数对象（function object)

- 该类是一个没有数据只有一个方法的类；
- 将泛型对象放在方法内部进行传递；

## 三. 运行时间分析

### 1. 一般法则

#### (1) for循环

- for循环的运行时间至多是该for循环内部哪些语句的运行时间乘以迭代次数；

#### (2) 嵌套for循环

- 从里向外顺序分析循环；
- 在一组嵌套循环内部的一条语句总的运行时间为该语句的运行时间乘以改组中所有的for循环的大小和乘积；

#### (3) 顺序语句

- 将各个语句的运行时间求和即可；

#### (4) if/else语句

- 一个if/else语句的运行时间不超过判断的运行时间加上，判断内容最长的运行时间；

### 2. 运行时间的对数

#### (1) 折半查找

#### (2) 欧几里得算法

- 计算公约数的欧几里得算法

```java
public static long gcd(long m, long n){
    while (n != 0){
        long rem = m % n;
        m = n;
        n = rem;
    }
    
    return m;
}
```

- 定理
  - 如果$$M>N$$，则$$M mod N < M/2$$;

#### (3) 幂运算

```java
public static long pow(long x, int n){
    if (n == 0)
        
        return 1;
    if (n == 1)
        return x;
    
    if (n % 2 == 0)
        
        return pow (x * x, n/2);
    else
        
        return pow (x * x, n/2) * x;
    
}
```

# 第二章  基本数据结构

## 一. 抽象数据类型（ADT）

- 数组：数组特点拥有index索引、高效查询及低效结构更改；

- 链表：低效查询、高效结构更改；

- 栈：先进先出；

- 队列：先进后出；

## 二. 树

### 1. 基础知识

#### (1) 结构概念

- 树是由一个根节点与0个或多个子树结合而成；
- 每个子树为根r的儿子；
- 子树中每棵的根都被来自根r的一条有向边所连接；
- 一棵树是由N个节点与N-1条边组成；
- 没有儿子的节点为树叶；

#### (2) 树的遍历方式

- 前序遍历
  - 对节点的处理工作在它诸儿子节点处理顺序之前；
- 后序遍历
  - 对节点的处理工作在它诸儿子节点处理顺序之后；
  - 可以实现数学算式的后缀表达式；

### 2. 二叉树

#### (1) 主要性质

- 每个节点拥有不多于两个儿子节点的树；
- 平均二叉树的深度要比节点个数N小得多（平均深度为$$O(\sqrt{N})$$）；
- 二叉查找树深度平均值为（平均深度为$$O(logN)$$）；
- 摊还时间：当M次操作的序列总的最长运行时间为$$O(Mf(N))$$,则摊还时间为$$O(f(N))$$

#### (2) 二叉查找树

- 主要性质：

  - 树中每个节点左子树中所有值要小于节点值；

  - 树中每个节点右子树中所有值要大于节点值；

  - 内部路径长：一棵树的所有节点的深度和；

  - 一N节点树的内部路径长($$D(N)$$)的递推公式为：
    $$
    D(N)=D(i)+D(N-i-1)+N-1
    $$

    $$
    D(N)=\frac{2}{N}[\sum_{j=0}^N D(j)]+N+1
    $$

    - $$D(i)$$为i节点左子树；

    - $$D(N-i-1)$$为$$N-i-1$$节点右子树；

#### (3) 平衡二叉树

- 带有平衡条件的二叉查找树；
-  每个节点的左子树和右子树的高度最多差1(-1表示为null)的二叉查找树；
- 利用旋转来保持树的平衡：
  - 平衡是被外部节点插入破坏的情况使用单旋转；
  - 平衡是被内部节点插入破坏的情况使用双旋转；
- 摊还时间为$$O(N)$$；

#### (4) 伸展树

- 定义：当一个节点被访问后，随后通过一系列AVL树的旋转被推到根上；
- 伸展树可以有效保证摊还时间为$$O(logN)$$;
- 展开
  - 在节点为访问后，沿着访问路径实施旋转操作后将访问节点推到根节点的过程；
  - 之字形（zig-zag）:子与父与父与爷路径相反；
  - 一字型（zig-zig）:子与父与父与爷路径相同；
  - 采用两次与路径方向相同的旋转进行调整；
- 当访问深度不够时使用伸展树有可能会降低访问效率；

### 3. B树

#### (1) 基础

- 数据项存储在树叶中
- 非叶节点存储到$$M-1$$个关键字以指示搜索的方向，关键字i代表子树$$i+1$$中的最小关键字；
- 树的根或者是一片树叶，或者其儿子数在$$2\sim M$$之间;
- 除根外，所有非叶子节点的儿子书在$$[M/2]\sim M$$之间；
- 所有树叶都在相同的深度上并有$$[L/2]\sim L$$之间个数据项；
- 一颗M叉查找树可以有M路分支，一只完全M叉树的高度大约为$$log_M N$$;

#### (2) B树的操作

- 向满叶子节点中插入数据，插入后进行分裂，父节点满后分裂向上传递；
- 删除后不满一半的叶子节点时
  - 首先向邻居节点领养一个邻项来矫正；
  - 若旁边节点在借了节点后也少于一半的情况，直接将两个节点进行结合；

## 三. 散列

### 1. 经典散列函数

#### (1) 基本性质

- 关键字的返回值一般为$$key\quad mode\quad Tablesize$$;

- 为了使散列表空间有效使用，一般表的大小一般为素数；

- 装填因子（$$\lambda$$）为已经存储的元素数与表大小之比；

- java中使用的散列函数$$\sum_{i=0}^{KeySize-1}Key[KeySize-i-1]*31^i$$;

  ```java
  public static int hash(String key, int tableSize) {
      int hashVal = 0;
      
      for (int i = 0; i < ket.length(); i++) {
          hashVal = 37 * hashVal + key.chartAt(i);
      }
      
      hashVal %= tableSize;
      if (hashVal < 0) {
          hashVal += tableSize;
      }
      
      return hashVal;
  }
  ```

#### (2) 分离链接法

- 将散列到同一个值的所有元素保留到同一个表中；
- 在java中hashMap使用的就是该方法，在每项中维护一个链表用来存储hash值重复的元素；
- 一次查找中，最不利情况下需要遍历$$1+(\lambda/2)$$条链；
- 在该方式中一般维持$$\lambda$$值为1左右，即预期插入数据数与表大小差距不大；

#### (3) 探测散列表（不使用链表的散列表）

- 基本性质

  - 函数的表达式
    $$
    h_i(x)=(hash(x)+f(i)) \quad mod \quad tableSize
    $$

  - 不使用分离链接法的散列表装填因子应该低于$$\lambda =0.5$$;
  - 再散列：随着散列表数据的增加，当$$\lambda$$大于等于临界值时对原有散列表进行扩容的操作；
    - 第一种方式：表满到一半直接再散列；
    - 第二种方式：插入失败进行再散列；
    - 第三种方式：途中策略（最具有优势的方式 ）；

- 线性探测法
  - $$f(x)$$函数的表达式$$f(i)=i$$;
  - 一次聚集：当表较空时，由于插入间隔为1，插入数据处聚集大量数据的现象；
  - 插入与最差查找的预期探测次数为$$\frac{1}{2}(1+\frac{1}{(1-\lambda)^2})$$;
  - 查找的最优探测次数为$$\frac{1}{2}(1+\frac{1}{(1-\lambda)})$$;
  
- 平方探测法
  - $$f(x)$$函数的表达式$$f(i)=i^2$$;
  - 当表大小为素数，且$$\lambda \leqq0.5$$时，总能向表中插入新元素；
  - 若表填充位置仅仅比一半多一个，也有可能导致插入失败；
  - 优势：避免了一次聚集；
  - 二次聚集：表示在插入数hash值相同时，他们将探测同一单元的现象；

- 双散列
  - $$f(x)$$函数的表达式$$f(i)=i*hash_2(x)$$;
  - 其中$$hash_2(x)$$可以采用$$R-(x \quad mod \quad R)$$这样的式子进行计算（R为小于tableSize的素数）;

#### (4) 完美散列

- 当知道需要插入的数据数量，确定一个散列算法与tableSize，使得可以一次性插入所有数据；
- 定理1：若N个球被放入$$M=N^2$$个盒子之中，则所有盒子中球的数量均不超过1的概率不小于$$1/2$$;
- 定理2：若N个项被放入包含N个盒子的主散列表中，则要保证所有盒子中球的数量均不超过1的概率不小于$$1/2$$需要的二级散列表总容量为2N；

### 2. 新式散列函数

#### (1) 布谷鸟散列

- 维护多张半满表，分别用不同的散列算法对两张表进行计算；
- 每个数据插入时会直接插入第一张表，然后原有数据直接插入第二张表，第二张表中数据又插入第一张表，依次内推，直到数据完全插入表中；
- 表的装填因子小于0.5时，产生插入循环的概率非常低；
- 表的装填因子小于0.5时，成功插入需要超过$$O(logN)$$次数的概率时极低的;
- 在查找时可以通过，多表并行的方式进行查找；
- 在布谷鸟散列中插入方法的实现中
  - 使用随机方式进行替换；
  - 第一项、最后一项及按序列替换插入效率要低于随机替换；
- 使用两个分开的表的经典布谷鸟散列期望值上界大概为$$1/(1-(4\lambda^2)^{1/3})$$;
- 且越接近1/2越差，因此最大填充因子可以选择小一点（0.4）或者选择多于两个的散列函数；

#### (2) 跳房子散列

- 线性探测算法的改善；
- 维护一个探索最大探索序列的上界（MAX_DIST）来保证探索为常数时间；

#### (3) 通用散列法

- 满足条件
  - 散列函数计算时间必须为常数；
  - 散列函数各项在数组中的分布是均匀的；
- 定义
  - M表示tableSize；  
  - 如果对任意的$$x \ne y$$，散列函数族$$H$$中有$$H(x)=h(y)$$的散列函数h的个数至多为$$|H|/M$$，则一个散列函数族H是通用的；
  - 如果对任意的$$x_1 \ne y_1$$，$$x_2 \ne y_2$$，$$x_3 \ne y_3$$，$$x_k \ne y_k$$，$$H$$中有$$H(x_1)=h(y_1)$$，$$H(x_2)=h(y_2)$$，$$H(x_3)=h(y_3)$$，$$H(x_k)=h(y_k)$$的散列函数h的个数至多为$$|H|/M^k$$，则一个散列函数族$$H$$是$$k-$$通用的；
  - 散列族$$H=$${$$H_{a,b}(x)=((ax+b)\quad mod\quad p)\quad mod \quad M$$，其中$$1\leqq a\leqq {p - 1}$$，$$1\leqq b\leqq {p - 1}$$}成立； 
  - 梅森素数：
    - 使用位移运算与一次减法完成的素数，如：$$2^{31} - 1$$，$$2^{5} - 1$$等；
    - 一次对梅森素数取模的操作可以使用位移运算和一次加法完成；

## 四. 优先队列（堆）

### 1.  二叉堆

#### (1). 结构性质

- 一颗被完全填满的二叉树（完全二叉树）；
- 新加入的元素从叶子节点从左到右依次填入；
- 高为h的完全二叉树有$$2^h$$到$$2^{h+1} - 1$$个节点；
- 使用数组实现的完全二叉树
  - 任意位置$$i$$上的元素，左儿子在$$2i$$，右儿子在$$2i+1$$；
  - 父节点的位置为$$\lfloor i/2 \rfloor$$;

#### (2). 堆序性质

- 让操作快速执行的性质；
- 最小值应该在根上；
- 在一个堆中，对于每一个节点$$X$$，$$X$$的父亲中的关键字小于（或等于）$$X$$中的关键字，根节点除外；

#### (3). 定理

- 包含$$2^{h+1}-1$$个节点、高为h的理想二叉树的节点高度和为$$2^{h+1}-1-(h+1)$$;

### 2. d-堆

- 大致上与二叉堆一致，唯一的不同就是每个节点有d个子节点；
- 插入数据的时间复杂度低于二叉堆（$$O(log_d(N))$$）；
- 删除最小值的时间复杂度高于二叉堆（$$O(dlog_d(N))$$）；
- 由于实际操作中，插入数据的次数要远远多余删除最小数据的次数，因此d-堆效率是要高于二叉堆的；

### 3. 左式堆（leftist heap）

#### (1). 定义

- 能有效支持合并操作（使用链表）；
- 与二叉堆相同，都具有结构性和有序性；
- 零路径长（null path）：
  - 从节点到一个不具有两个儿子节点的最短距离；
  - 具有一个儿子或者没有儿子的节点的零路径长为0；
  - 每个节点的零路径为它儿子节点的零路径最小值+1；
  - 空节点的零路径为-1；
- 左式堆中，左儿子的零路径长不小于右儿子；
- 在右路径上右r个节点的左式堆必然至少由$$2^r - 1$$个节点；

### 4. 斜堆

- 左式堆的自调节形式；
- 斜堆是具有堆序的二叉树，但不存在对树的结构的限制；
- 所有操作的运行时间最长为$$O(N)$$；
- 与伸展树一样，连续操作M次运行的最长时间为$$O(Mlog(N))$$；
- 在斜堆合并过程中，除右节点最大值除外，都需要交换他的左右节点；

### 5. 二项队列

#### (1). 结构

- 二项队列不是一颗堆序的树，而是堆序树的结合，称为森林；
- 其中每棵树都具有一定的约束，叫做二项树；
  - 每个高度上至少存在一颗二项树；
  - 高度为0的二项树是一颗单节点树；
  - 高度为k的二项树$$B_k$$通过将一颗二项树$$B_{k-1}$$附在另一二项树$$B_{k-1}$$的根上构成的；
  - 二项树$$B_k$$由一个带有儿子的$$B_0$$，$$B_1$$，$$B_2$$，. . .，$$B_{k-1}$$的根组成；
  - 高度为k的二项树恰好有$$2^k$$个节点；
  - 将堆序施加到二项树上并允许任意高度上最多一颗二项树，那么可以使用二项树的集合表示任意大小的优先队列；
  - 可以使用二进制数表示优先队列，如大小为13的优先队列可以表示为1101（其中有$$B_3$$，$$B_2$$，$$B_0$$）；

#### (2). 二项队列操作 

- 最小元查找可以通过搜索所有的树的根来找出，由于最多有$$logN$$颗不同的树，因此查找最小值时间为$$O(logN)$$;
- 合并操作基本上是通过将两个队列加到一起来完成的，合并其中相同的项（$$O(logN)$$操作时间）；
- $deleteMin$可以通过找出一颗具有最小根的二项树来完成；

### 6. 优先队列的使用

#### (1). 选择问题

- 问题描述：确定一组数中的第k个最大者；
- 采用堆排序的方式解答该问题$$Nlog(N)$$；
- 采用拥有k个元素的堆进行处理$$Nlog(N)$$；

#### (2). 事件模拟

- 使用一份单位时间量（滴答tick），来代替一天中准确的时间；
- 每走过一个单位时间量，对其中的所有事件进行处理；
- 最后在所有顾客走光与所有出纳员都空闲时结束模拟；

## 五. 不相交集类

### 1. 等价关系

#### (1). 特性

- 若对于每一对元素$(a,b),a,b\in S,aRb$$或者为true或者为false，则称为集合S上定义关系$$R$；
- 如果$$aRb$$是true，则说a与b有关系；
- 等价关系$R$满足条件
  - （自反性）对于所有的$a\in S,aRb$；
  - （对称性）$aRb$当且仅当$bRa$；
  - （传递性）若$aRb$且$bRc$则$aRc$；
- 电气连通性：所有连接都是通过金属导线完成的；

#### (2). 动态等价性问题

-  一个元素$a\in S$的等价类是$S$的一个子集，包含所有与a有等价关系的元素；
- 初始类
  - 初始含有$N$个只包含一个元素的集合；
  - 初始所有集合之间的所有关系均为false；
  - 同时每个集合中的元素都不相同（$S_i \cap S_j = \varnothing$），使得所有集合都不相交；
- 初始类中允许使用两种操作
  - 查询（find）：查询包含给定元素的集合；
  - 添加关系（不相交集合的union/find算法）
    - 首先确定需要添加关系两个元素是否已经存在关系（寻找两个元素是否存在在同一个集合中）；
    - 不在同一个类中时，使用求并操作（union）将把含有两个元素的等价类合并为一个等价类（$S_k = S_i \cup S_j$）；

### 2. 基本数据结构

#### (1). 使用森林表示

- 使用树来表示每个集合（使用find方法返回树根节点）；
- 集合的名字是由根处的节点给出；
- 显式的使用数组来存储集合树，数组的每个成员$S[i]$表示元素$i$的父亲；
- 如果$i$是根，$S[i]=-1$；
- 一次$find$的最坏情形是$O(N)$；

#### (2). 基本实现

```java
/**
 * 不相交集类
 */
public class DisjointSet {
    /**
     * 不相交集类森林
     */
    private int[] disjoint;

    public DisjointSet(int numElements) {
        this.disjoint = new int[numElements];

        for (int i = 0; i < numElements; i++) {
            disjoint[i] = -1;
        }
    }

    /**
     * 合并集合方法
     * @param root1
     * @param root2
     */
    public void union(int root1, int root2) {
        disjoint[root2] = root1;
    }

    /**
     * 寻找x的根节点
     * @param x
     * @return
     */
    public int find(int x) {
        while (disjoint[x] >= 0) {
            x = disjoint[x];
        }

        return x;
    }
    
    /**
     * 按高度合并集合方法
     * @param root1
     * @param root2
     */
    public void heightUnion(int root1, int root2) {
        if (disjoint[root1] < disjoint[root2]) {
            heightUnion(root2, root1);
            
            return;
        } else if (root1 == root2){
            disjoint[root1] --;
        }

        disjoint[root2] = root1;
    }
}
```

### 3. 灵巧求并算法

#### (1). 按照大小求并

- 合并时按照大小求并，将较小的树合并到较大树之中去；
- 任何节点的深度均不会超过$logN$；
- 树的大小以其负数的形式代替之前全为-1的情况；

#### (2). 按高度求并

- 与大小不同，该方案是按照每棵树按高度合并；
- 任何节点的深度也不会超过$logN$；
- 平缓的算法，只有在两棵树高度相同时合并后树高度才会增加；

### 4. 路径压缩

#### (1). 定义

- 路径压缩是针对$find$操作而不影响$union$操作；
- 在$find$操作的过程中，从$x$到根的路径上的每一个节点都将该树的根作为其父节点；
- 连续$M$次运算最多需要$O(MlogN)$；
- 可以与按大小求并完全兼容，但和按高度求并不完全兼容；
- 由于路径压缩会改变树的高度，在每棵树存储的高度为估计的高度（称为秩），然后使用按秩求并代替按高度求并；

#### (2). 实现	

```java
public class DisjointSet {
     /**
     * 使用路径压缩来寻找x的根节点
     * @param x
     * @return
     */
    public int compressionFind(int x) {
        if (disjoint[x] < 0) {
            return x;
        }

        return disjoint[x] = compressionFind(disjoint[x]);
    }   
}
```

### 5. 路径压缩和按秩求并的最不利情形

#### (1). 缓慢增长函数

- 最不利情形需要的时间是$\Theta (M\alpha(M,N))$，其中，$\alpha(M,N)$是一个增长及其缓慢的函数；

- 递推式
  $$
  T(N) = \begin{cases}\begin{aligned}
  0\qquad\qquad\qquad \qquad N \leqq 1 \\
  T(\lfloor f(N) \rfloor) + 1 \qquad N > 1
  \end{aligned}
  \end{cases}
  $$

  - $T(N)$表示从N开始，必须迭代应用$f(N)$直到达到1（或更小）的迭代次数；
  - 在假设$f(N)$为一个已知函数，将等式的解称为$f^*(N)$；
  - $f(N) = logN$的解$T(N) = log^*N$称为迭代对数；

  |   $f(N)$    |   $f^*(N)$   |
  | :---------: | :----------: |
  |    $N-1$    |    $N-1$     |
  |    $N-2$    |    $N/2$     |
  |    $N-c$    |    $N/c$     |
  |    $N/2$    |    $logN$    |
  |    $N/c$    |   $log_cN$   |
  |  $\sqrt N$  |  $loglogN$   |
  |   $logN$    |   $log^*N$   |
  |  $log^*N$   | $log^{**}N$  |
  | $log^{**}N$ | $log^{***}N$ |

#### (2). 利用递归分解的分析

- 

# 第三章. 算法

## 一. 排序

### 1. 基础

#### (1). 简单排序算法的下界

- 逆序(inversion)：具有$$i<j$$但$$a[i]>a[j]$$性质的序偶$$(a[i],a[j])$$的数组叫做逆序;
- 定理：
  - $$N$$个互异数组成的数组其平均逆序数为$$N(N-1)/4$$；
  - 通过交换相邻元素进行排序的任何算法平均都需要$$\Omega(N^2)$$；

### 2. 插入排序

#### (1). 算法

- 插入排序是由$$N-1$$趟排序组成；

- 由$$p=1$$到$$N-1$$趟，插入排序保证从位置0到位置p上的元素已处于排序状态；

  ```java
  public static <T extends Comparable<? super T>> void insertionSort (T[] array) {
      if (array == null ||array.length <= 1) {
          return;
      }
      
      T temp;
      
      for (int i = 0; i < array.length - 1; i ++) {
          
          for (int j = i + 1; j < array.length; j++) {
              if (array[j].compareto(array[i]) {
                  temp = array[i];
                  array[i] = array[j];
                  array[j] = temp;
              }
          }
      }
  }
  ```

#### (2). 插入排序的分析

- 嵌套训话的每一个都花费N次迭代，插入排序为$$O(N^2)$$；
- 当输入数组预先排序好时使用时间为$$O(N)$$；
- 插入排序过程中进行逆序数次交换；
- 总的排序允许时间为$$O(I+N)$$，其中$$I$$为数组逆序数，N为数组长度；

$$
\sum_{i =2}^{N} = 2 +3 +4 + ... + N =\frac{(N+2)(N-1)}{2}=\frac{N^2+N-2}{2}=\Theta(N^2)
$$

### 3. 希尔排序

#### (1). 定义

- 希尔排序通过比较相距一定间隔的元素来工作，各趟比较作用的距离随着算法的进行而减小，直到只比较相邻元素的最后一趟排序为止；
- 希尔排序有时也可以叫做缩减增量排序；
- 增量序列（increment sequence）：具有$$h_1=1$$的任意单增互斥数组（一般做法时数据间隔为1）；
  - 希尔排序使用增量序列中$$h_k$$进行排序后，对于任意$$i$$都有$$a[i]\geqq a[i+h_k]$$，现数组称为是$$h_k$$排序的（$$h_k$$-sorted）；
  - 一个$$h_k$$排序的数组，在进行后续排序（$$h_{k-1}$$排序）时会保持他的排序性；

#### (2). shell序列的希尔排序实现

- 流行的shell建议的序列（不是很好）：$$h_t=\lfloor N/2 \rfloor$$和$$h_k=\lfloor h_{k+1}/2 \rfloor$$；

- 使用shell序列的希尔排序最坏情形的运行时间为$$\Theta (N^2)$$；

  ```java
  public static <T extends Comparable<? super T>> void shellSort (T[] array) {
      if (array == null ||array.length <= 1) {
          return;
      }
      
      T temp;
      int j;
      
      for (int h = array.length / 2; h > 0; h /= 2) {
      	
      	for (int i = h; i < array.length; i ++) {
      		temp = array[i]
      		
       		for (j = i; j >= h && temp.compareTo(a[j - h] < 0; j -= h)) {
       			array[j] = a[j - h];
       		}
              
              a [j] = temp; 
          }	
      }
  }
  ```

#### (3). hibbard序列的希尔排序实现

- hibbard增量序列：$$h_k = 2^k - 1$$;
- 使用hibbard增量的希尔排序的最坏情形的运行时间为$$\Theta (N^{3/2})$$；

### 4. 堆排序

#### (1). 基础

- 为了避免在二叉堆中使用多个数组，可以使用位于堆中最后的单元用来存放刚deleteMin删除的元素；
- 定理
  - 对N个互异项的随机排列进行堆排序所用比较的平均次数为$$2NlogN-O(NloglogN)$$；

#### (2). 实现

```java
/**
* 节点向下推函数
*/
private static void perDown() {

    T temp;
    int child;
    int i = 1;

    for (temp = array[i]; leftChild(i) < currentSize; i = child) {
        child = leftChild(i);

        if (child != currentSize - 1 && array[child].compareTo(array[child + 1]) < 0) {

            child ++;
        } if ( temp.compareTo(array[child]) < 0) {

            array[i] = array[child];
        } else
            break;
    }

    array[i] = temp;

}
```

### 5. 归并排序

#### (1). 基础

- 归并排序以$$O(NlogN)$$的最差情况运行；
- 归并排序是基本操作是合并两个已排序的表；
- 使用分治策略将数组分成若干份，然后进行合成；
- 使用递归策略进行合并；
- 在排序过程之中，会使用到线性附加内存；
- 与其余运行时间为$$O(NlogN)$$的排序方法相比，归并排序的运行时间严重依赖于比较元素和在数组中移动元素的相对开销（越大越不利）；

#### (2). 实现

```java
	/**
	* 主函数
	*/
	public static<T extends Comparable<? super T>> 
    void mergeSort (T[] a1, T[] tempArray, int left, int right) {
        
        if (left < right) {
            int center = (left + right) / 2;
            mergeSort(a1, tempArray, left, center);
            mergeSort(a1, tempArray, center + 1, right);
            merge(a1, tempArray, left, center + 1, right);
        }
    }
    
	/**
	* 合并前后有序数组
	*/
    private static <T extends Comparable<? super T>>
    void merge (T[] a, T[] tempArray, int leftPos, int rightPos, int rightEnd) {
        int leftEnd = rightPos - 1;
        int tmpPos = leftPos;
        //数组总长度
        int numElements = rightEnd - leftPos + 1;
        
        while (leftPos <= leftEnd && rightPos <= rightEnd) {
            
            if (a[leftPos].compareTo(a[rightPos]) < 0) {
                tempArray[tmpPos ++] = a[leftPos ++];
            } else {
                tempArray[tmpPos ++] = a[rightPos ++];
            }
        }
            
        while (leftPos <= leftEnd) {
            tempArray[tmpPos ++] = a[leftPos ++];
        }

        while (rightPos <= rightEnd) {
            tempArray[tmpPos ++] = a[rightPos ++];
        }

        for (int i = 0; i < numElements; i ++, rightEnd --) {
            a[rightEnd] = tempArray[rightEnd];
        }
    }
```

### 6. 快速排序

#### (1). 基础知识

- 快速排序算法使用非常精练和高度优化的内部循环；
- 运行时间最差为$$O(N^2)$$，平均运行时间为$$O(NlogN)$$；
- 与归并排序一样，也是一种分治的递归算法；
- 由于对于数据量较小的数组（<20）来说，快速排序不如插入排序，因此在数组大小被分割到足够小（10）时使用插入排序来提高效率；

#### (2). 实现

- 如果S中元素为0或者1，直接返回；

- 随便选取一项S，称之为枢纽元；

- 剩下元素分为两个不相关的集合，前一个集合的所有元素都小于枢纽元，后一个集合的所有元素都大于枢纽元；

- 对不相交集合分别递归使用该算法；

  ```java
     /**
       * 快速排序的实现
       * @param a
       * @param <T>
       */
      public static <T extends Comparable<? super T>>
      void quicksort(T[] a) {
          quicksort(a, 0, a.length - 1);
      }
  
      /**
       * 快速排序的实现
       * @param a
       * @param left
       * @param right
       * @param <T>
       */
      public static <T extends Comparable<? super T>>
      void quicksort(T[] a, int left, int right) {
          if (left + CUTOFF < right) {
              T media = median3(a, left, right);
  
              int start = left;
              int end = right - 1;
  			
              //速度快的核心
              for (;;) {
                  
                  while (a[start ++].compareTo(media) <= 0) {}
                  while (a[end --].compareTo(media) >= 0) {}
                  
                  if (start < end) {
                      swap (a, start ++, end --); 
                  } else {
                      break;
                  }
              }
              
              swap (a, start, right - 1);
  
              quicksort(a, left, start - 1);
              quicksort(a, start + 1, right);
          }else {
              insertionSort(a, left, right);
          }
  
      }
  
      /**
       * 执行三数中值分割法选择最小值
       * @param a
       * @param left
       * @param right
       * @param <T>
       */
      private static <T extends Comparable<? super T>>
      T median3(T[] a, int left, int right) {
  
          int middle = (left + right) / 2;
  
          if (a[middle].compareTo(a[left]) < 0) {
              swap(a, left, middle);
          }
  
          if (a[right].compareTo(a[left]) < 0) {
              swap(a, left, right);
          }
  
          if (a[right].compareTo(a[middle]) < 0) {
              swap(a, middle, right);
          }
  
          //将枢纽元放置在right-1的位置上
          swap(a,middle,right -1);
  
          return a[right - 1];
      }
  
      /**
       * 交换两个数组中两位置的元素
       * @param a
       * @param left
       * @param right
       * @param <T>
       */
      private static <T extends Comparable<? super T>>
      void swap(T[] a, int left, int right) {
          T temp = a[left];
          a[left] = a[right];
          a[right] = temp;
      }
  ```

#### (3). 枢纽元的选取

- 将第一个元素作为枢纽元（最差情况）；
- 随机选取枢纽元是一种保险的方法；
- 三数中值分割法
  - 用来替换选取数组所有数中的中位数；
  - 使用随机三个数中的中值作为枢纽元；
  - 一般做法选择左端点，右端点及中间位置的三个数来进行分割数的计算；

#### (4). 分割策略

- 将选取的枢纽元与最后一个元素交换；
- 然后利用双指针将小于枢纽元的元素放在左边，大于枢枢纽元的元素放置在右边；
- 最后将大元素的右左端点与枢纽点交换；

### 7. 相关下界问题

#### (1). 排序算法一般下界

-  决策树

  - 决策树是用于证明下界的抽象概念；

  - 决策树的构成
    - 算法初始状态为根节点（未进行比较）；
    - 每个节点表示元素之间可能的排序（与已经进行的比较一致）；
    - 比较结果为树的边；
    - 排序算法所使用的比较次数等于最深的树叶深度；

  - 通过只使用比较的进行排序的每一种都算法都可以使用决策树来表示；

- 定理

  - 令T是深度为d的二叉树，则T最多有$$2^d$$片树叶；

  - 具有$$L$$片树叶的二叉树深度至少为$$\lceil log L \rceil$$;

  - 只使用元素间比较的任意排序算法在最坏情况下最少需要$$\lceil log (N!) \rceil$$次比较；

  - 只使用元素间比较的任何排序算法均需要$$\Omega(NlogN)$$次比较；

  - 如果存在P种不同的可能情况要区分，而问题是$$yes/No$$的形式，那么通过任何算法求解该问题在某种情形下总需要$$\lceil logP \rceil$$个问题；

#### (2). 选择问题的决策树下界

- 如果决策树所有叶子都有深度$$d$$或者更深，则决策树必须至少有$$2^d$$个叶子；
- 对于任何基于比较的算法，找最小元都至少用$$N-1$$次比较；
- 从$$N$$个元素中找出最小元的决策树必须最少有$$2^{N-1}$$个叶子；
- 从N个元素中找第$$k$$小元素的决策树一定有至少$$(\begin{matrix} N\\k-1\\ \end{matrix})2^{N-k}$$个叶子；
- 任何基于比较找第$$k$$小元的算法必须至少用$$N-k+ \lceil log(\binom {N} {k-1}) \rceil$$次比较；
- 任何基于比较找中位元素的算法必须至少用$$\lceil 3N/2 \rceil - O(logN)$$次比较；

#### (3). 对手下界

- 步骤
  - 证明必须由解决某个问题来获得一些信息的基本量；
  - 在算法的每一步，对手将维护一个输入，与该算法当前提供的答案一致；
  - 论证在步骤不足的情况下，存在多种一致的输入，可以给算法提供不同的答案；
- 定义
  - 对于任意基于比较的算法，同时找到最小和最大元都至少用$$\lceil 3N/2 \rceil - 2$$次比较；

### 8. 线性时间排序

#### (1). 桶排序

- 使用条件：输入数据$$A_1, A_2, A_3, ..., A_N$$须由小于M的正整数组成。
- 算法时间复杂度：$$O(N)$$；
- 算法：
  - 使用一个大小为$$M$$的成为count的数组，初始化全为0 ；
  - 于是count有$$M$$个单元（或称为桶）；
  - 当读入$$A_i$$时，$$count[A_i]$$增1;
  - 在所有数据都被读入后，扫描count数组，打印出排序后的表；

#### (2). 基数排序

- 由于曾用于对老式穿孔卡片进行排序，也称为卡片排序；

- 对某常数$$p$$考虑值域从$$0\sim b^p - 1$$的$$N$$个数字，从最低位数字使用桶排序直到最高位；

- 计数基数排序
  - 基数排序的一种实现
  - 使用计数器来记录每个桶中装元素的个数（$$count[k]$$就是桶$$k$$中元素的个数）；
  - 同时使用offset数组，其中$$offset[k]$$表示严格小于$$k$$的元素个数；
  
- 实现

  ```java
  public class SortUtil {
  	/**
       * 默认基数排序中桶数组大小
       */
      private final static int BUCKETS = 256;
  
      /**
       * 基数排序的实现
       */
      public static void radixSort(String[] arr, int stringLen) {
  
          //设置桶，其中
          ArrayList<String>[] buckets = new ArrayList[BUCKETS];
  
          for (int i = 0; i < BUCKETS; i++) {
              buckets[i] = new ArrayList<>();
          }
  
          //从尾部向前依次添加元素
          for (int pos = stringLen - 1; pos >= 0; pos --) {
              for (String s : arr) {
                  buckets[s.charAt(pos)].add(s);
              }
  
              int idx = 0;
              //按照排序后的顺序重新插入
              for (ArrayList<String> bucket : buckets) {
                  for (String s : bucket) {
                      arr[idx ++] = s;
                  }
  
                  bucket.clear();
              }
          }
      }
      
      /**
       * 计数基数排序的实现
       * @param arr
       * @param stringLen
       */
      public static void countingRadixSort(String[] arr, int stringLen) {
          int N = arr.length;
          String[] buffer = new String[N];
          //in代表arr
          String[] in = arr;
          //out代表临时数组buffer
          String[] out = buffer;
  
          for (int pos = stringLen - 1; pos >= 0; pos --) {
              int[] count = new int[BUCKETS + 1];
  
              //设置pos位置的count数组
              for (int i = 0; i < N; i++) {
                  count[in[i].charAt(pos) + 1] ++;
              }
  
              //优化count数组
              for (int i = 1; i < BUCKETS; i++) {
                  count[i] += count[i - 1];
              }
  
              //将重新排序
              for (int i = 0; i < N; i++) {
                  out[count[in[i].charAt(pos)] ++] = in[i];
              }
  
              String[] tmp = in;
              in = out;
              out = tmp;
          }
  
          //如果arr数组是奇数，in是buffer，out是arr，换回来；
          if (stringLen % 2 == 1) {
              for 外部排序
  1. 基本定义
  当数据量过大无法直接在内存中进行操作时，通过平衡内存访问次数与时间复杂度的方式来提高效率；
  
  磁带只有以（两个方向上）连续的顺序才能够被有效的访问；
  
  2. 简单排序(int i = 0; i < arr.length; i++) {
                  out[i] = in[i];
              }
          }
      }
      
      /**
       * 变长字符串的基数排序的实现
       * @param arr
       * @param maxLen 最长字符串的长度
       */
      public static void LengthenRadixSort (String[] arr, int maxLen) {
          //根据长度设置桶
          ArrayList<String>[] wordsByLength = new ArrayList[maxLen + 1];
          //所使用的桶
          ArrayList<String>[] buckets = new ArrayList[BUCKETS];
  
          for (int i = 0; i < maxLen + 1; i++) {
              wordsByLength[i] = new ArrayList<>();
          }
  
          for (int i = 0; i < BUCKETS; i++) {
              buckets[i] = new ArrayList<>();
          }
          
          //根据字符串长度添加到桶中
          for (String s : arr) {
              wordsByLength[s.length()].add(s);
          }
          
          //将arr中的数组按字符串长度进行排序
          int idx = 0;
          for (ArrayList<String> wordlist : wordsByLength) {
              for (String s : wordlist) {
                  arr[idx ++] = s;
              }
          }
          
          int startingIndex =  arr.length;
          
          for (int pos = maxLen - 1; pos >= 0; pos --) {
              startingIndex -= wordsByLength[pos + 1].size();
  
              for (int i = startingIndex; i < arr.length ; i++) {
                  buckets[arr[i].charAt(pos)].add(arr[i]);
              }
              
              idx = startingIndex;
  
              for (ArrayList<String> bucket : buckets) {
                  for (String s : bucket) {
                      arr[idx ++] = s;
                  }
                  
                  bucket.clear();
              }
          }
      }
  }
  ```
  

### 9. 外部排序

#### (1). 基本定义

- 当数据量过大无法直接在内存中进行操作时，通过平衡内存访问次数与时间复杂度的方式来提高效率；
- 磁带只有以（两个方向上）连续的顺序才能够被有效的访问；

#### (2). 简单排序

- 需要4盘磁带（两盘输入磁带与两盘输出磁带）；
- 内存一次可以容纳$$M$$个记录，一次性获取M条数据进行排序，然后将排序好后的记录写入磁盘中；
- 每次排好序的记录叫做一个顺串；

#### (3). 多路合并

- 使用额外的磁盘来减少输入数据排序所需要的趟数；
- 通过将基本的$$2-$$路合并扩充到$$k-$$路合并实现；
- 通过使用优先队列找出k路中的最小元；
- 需要使用$$2k$$盘磁带；

#### (4). 多相合并

- 需要使用$$k+1$$盘磁带完成排序工作；

## 二. 图论算法

### 1. 基础

#### (1). 定义

- 一个图$G=(V,E)$由顶点的集$V$和边的集$E$组成；
- 每一条边就是一点幅点对$(v,w)$，其中$v,w \in V$（边也叫做弧）。
- 在一个图中，当且仅当$(v,w)\in E$，则称顶点$v$与$w$邻接 。
- 当点对有序时，图就是有向的，也称为有向图；
- 边也可以拥有权和值；
- 图中存在是由顶点序列$w_1, w_2, w_3, w_4,...,w_N$$((w_i,w_{i+1}) \in E, 其中1 \leqq i < N)$组成的路径；
  - 路径的长为该路径的变数，等于$N-1$；
  - 一个顶点可以看作一个边长为0的边；
  - 如果含有一条从一个顶点到他自身的边$(v,v)$，那么路径$v,v$有时也叫做环；
  - 简单路径：除了第一个顶点与最后一个顶点外的所有顶点都是互异的一条路径；
- 有向图中的圈表示的是长度不为0的有向环（圈为简单路径时称为简单圈）；
- 无向图中如果每一个顶点到其他所有顶点都存在路径，则该无向图就是连通的；
- 有向图的连通
  - 具有联通无向图性质的有向图则称为**强连通的**；
  - 当有向图不是强连通的，但基础图（结构相同的无向图）是连通的，则称该有向图弱连通；
- 每一对顶点间都存在一条边的图就是完全图；

#### (2). 图的表示

- **邻接矩阵**表示法
  - 使用一个**二维数组**$(array)$来表示图；
  - 使用$array[u][v]$表示每条边，为$true$时存在，$false$时不存在，或者表示该边权重；
  - 空间需求：$\Theta (|V|^2)$;
  - 邻接矩阵主要是用来表示边稠密的图；
- **邻接表**表示法（图表示的标准方法）
  - 使用一个表来存放当前节点所有的邻接顶点；
  - 空间需求：$\Theta (|V|+|E|)$;
  - 可以用来表示稀疏的图；

### 2. 拓扑排序

#### (1). 基础

- 拓扑排序是面对有向无圈图的顶点的一种排序；
- 当存在一条$v_i$到$v_j$的路径时，排序中$v_j$出现在$v_i$之后；
- 顶点$v$的**入度**：定义为边$(u,v)$的条数；

#### (2). 算法实现

- 实现步骤
  - 简单的实现为优先找出一个没有任何入边的顶点；
  - 然后选出该边同时删除他相关边；
  - 最后重复该操作；
  - 可以将顶点的入度存储在邻接表中；
  
  ```java
  package graph.adjacencyList;
  
  import java.util.*;
  
  /**
   * 邻接表实现
   */
  public class AdjacencyList<T> {
  
      /**
       * 邻接列表节点列表
       */
      private LinkedList<Vertex<T>> list;
  
      /**
       * 节点个数
       */
      private Integer numVertex;
  
      public AdjacencyList() {
          list = new LinkedList<>();
          numVertex = 0;
      }
  
      public AdjacencyList(LinkedList<Vertex<T>> list) {
          this.list = list;
  
          for (Vertex vertex : list) {
              numVertex ++;
          }
      }
  
      public void add (Vertex<T> vertex) {
          list.add(vertex);
          numVertex ++;
      }
  
      /**
       * 拓扑排序
       */
      public List<Vertex<T>> topSort ()
              throws Exception{
          LinkedList<Vertex<T>> vertices = copyList();
          Queue<Vertex<T>> inDegreeZeroList = new ArrayDeque<>();
          List<Vertex<T>> topSortList = new ArrayList<>();
          int count = 0;
  
          for (Vertex<T> vertex : vertices ) {
              if (vertex.inDegreeNumber == 0) {
                  inDegreeZeroList.add(vertex);
              }
          }
  
          while (! inDegreeZeroList.isEmpty()) {
  
              Vertex<T> peek = inDegreeZeroList.peek();
              topSortList.add(peek);
              count ++;
  
              for (Vertex<T> vertex : peek.outDegreeNode) {
                  if (-- vertex.inDegreeNumber == 0) {
                      inDegreeZeroList.add(vertex);
                  }
              }
          }
          
          return topSortList;
      }
  
      /**
       * 复制图
       * @return
       */
      private LinkedList<Vertex<T>> copyList () {
  
          LinkedList<Vertex<T>> copyList = new LinkedList<>();
          for (Vertex<T> vertex : list) {
              if (vertex == null) {
                  copyList.add(null);
              }
  
              copyList.add(vertex.copy());
          }
  
          return copyList;
      }
  
      /**
       * 寻找入度为0的节点
       * @return
       */
      private Vertex<T> findNewVertexOfInDegreeZero (LinkedList<Vertex<T>> list) {
  
          for (Vertex<T> vertex : list) {
              if (vertex.inDegreeNumber == 0)
                  return vertex;
          }
  
          return null;
      }
  
  
      /**
       * 邻接表节点实现
       */
      class Vertex<T> {
  
          /**
           * 节点数据
           */
          T t;
  
          /**
           * 节点的入度
           */
          Integer inDegreeNumber;
  
          /**
           * 出度表
           */
          LinkedList<Vertex<T>> outDegreeNode;
  
          public Vertex() {
          }
  
          public Vertex(T t, Integer inDegreeNumber, LinkedList<Vertex<T>> outDegreeNode) {
              this.t = t;
              this.inDegreeNumber = inDegreeNumber;
              this.outDegreeNode = outDegreeNode;
          }
  
          Vertex<T> copy () {
              return new Vertex<T>(t,inDegreeNumber,outDegreeNode);
          }
      }
  }
  
  ```

### 3.最短路径算法

#### (1). 基础知识

- **赋权路径长**：与每条边$(v_i,v_j)$相联系的是穿越该弧的代价（或称为值）$c_{i,j}$，其中一条路径为$v_1,v_2,...,v_N$的值是$\sum_{i=1}^{N-1} c_{i,i+1}$；
- **无权路径长**：指的是路径上的边数；

#### (2). 单源最短路径问题

- 给定一个赋权图$G=(V,E)$和一个特定顶点$s$作为输入，作为从$s$到$G$中每一个其他顶点的最小赋权路径；
- 当路径中存在权重为负值时，出现最短路径不确定的循环的循环就叫作**负值圈**；

#### (3). 图的最短路径

- **广度优先搜索**（无权图）

  - 按层处理顶点：距·开始点最近的那些顶点优先被搜索（与树的层序遍历相似）；
  - 记录数据
    - know项表示顶点是否被处理（处理后置为true）；
    - $d_v(dist)$表示出发点到该顶点处的距离；
    - $p_v(path)$表示实际路径（路径上前一顶点）；
  - 使用队列来依次存储距离为当前距离的顶点；
  - 实现


  ```java
  /**
  * 广度优先搜索
  */
  public void unweighted (Vertex<T> s) {
      LinkedList<Vertex<T>> vertices = copyList();
  
      for (Vertex<T> vertex : vertices ) {
          vertex.dist = Integer.MAX_VALUE;
          vertex.know = false;
      }
  
      s.dist = 0;
  
      for (int i = 0; i < numVertex; i++) {
          for (Vertex<T> vertex : vertices ) {
              if (!vertex.know && vertex.dist == i) {
                  vertex.know = true;
  
                  for (Vertex<T> v : vertex.outDegreeNode) {
                      v.dist = i + 1;
                      v.path = vertex;
                  }
              }
          }
      }
  }
  ```


-  贪婪$(Dijkstra)$算法（赋权图）
  - 解决步骤
    - 选择当前所有$unkown$节点中具有最小d的节点$v$，同时声明$s$到$v$的最短距离是已知的；
    - 当$d_w$的新值$d_v+c_{v,w}$由于当前最短路径，则将替换为新值$d_v+c_{v,w}$；
    - 循环直到所有节点都查看到；
  - 更新节点$d_w$的两种方式
    - 使用优先队列一次$deleteMin$来对选择顶点$v$；
    - 每次$w$的距离变化把$w$和新值$d_w$存到队列中；

-  存在负值边图的最短路径分析
  - 使用与贪婪算法相似的算法来解决该问题（没有know字段）；
  - 使用赋权与无权的算法相结合来解决该问题；

-  无圈图

  - 对于无圈图，可以通过改变声明节点为$know$的顺序（顶点选取法则）来改变$(Dijkstra)$算法；

  - 重要用法：**关键路径分析法**；

  - **动作节点图**
    - 每个节点表示一个必须执行的动作以及完成动作所花费的时间；
    - 边$(v,w)$表示动作$v$必须在动作$w$开始前完成；

  - **事件节点图**
    - 每个事件对应一个动作和所有相关的动作的完成；
    - 在一个动作依赖于几个其他动作的情况下，可以需要插入哑边和哑点；

  - $EC_i$是节点$i$的**最早完成时间**
    $$
    EC_1 = 0 \\
    EC_w=max(EC_v + c_{v,w})
    $$

  - 每个事件能够完成又不影响最后完成时间的**最晚时间**
    $$
    LC_1 = EC_n \\
    LC_v=min(LC_w - c_{v,w})
    $$

  - 边的松弛时间（$slack_(v,w)$）
    $$
    slack_(v,w) = LC_w - EC_w =  LC_w - EC_v - c_{v,w}
    $$

  - **关键路径**是一条完全由零-松弛边组成的路径；

### 4. 图相关问题

#### (1). 最大流问题

- 计算从起点到终点可以通过·的最大流量；
  - 没有边的负载可以超过其容量；
  - 一个顶点可以以任何方式结合和发送流；
  - 保持边的容量以及流守恒；
- **流图$G_f$**：算法在任意阶段已经达到的流；
- **残余图$G_r$**：表示每条边还能再添加多少流，对于每条边，我们可以从容量中减去当前的流而计算残余的流；
- **增广路径**：从起点到终点的一条路径；
- 算法规则
  - 分为多个阶段寻找从起点到终点的路径直到不存在任何起点到终点的路径；
  - 在每个阶段之中，增广路径上的最小边值就是添加到该路径上每条边上的路径；
  - 一旦注满一条边，则该边就要从残余图中除去；
  - 为了改善算法，对于流图中具有流$f_{v,w}$的每一边$(v,w)$，在残余图中添加一条容量为$f_{v,w}$的每一边$(w,v)$；
  - 选择增广路径方法
    - 选择容许在流中最大增长的增广路径；
    - 选择具有最少边数的路径；

#### (2). 最小生成树问题

- 一个**无向图**的最小生成树就是由该图的那些连接该图所有顶点的边构成的总价值最低的树；
  - 只有图是连通时，才存在最小生成树；
  - 在算法中应该验证图是否连通；
  - 最小生成树中边的条数是$|V|-1$，其中$V$表示图的顶点数；
  - 总价值指的是所有边权值之和；
  - 贪婪策略：Prim算法与Kruskal算法；
- Prim算法
  - 在建立生成树时选取所有避免成圈的边中的最小值；
  - 每一步，都要把一个节点当作根并往上加边，也把相关联的顶点加到增长中的树上；
  - 每一阶段通过选择边$(u,v)$使得$(u,v)$的值是所有$u$在树上而$v$不在树上的边的值中的最小者；
- Kruskal算法
  - 按照最小权选取边，只有当所选择的边不产生圈时就把它作为所取定的边；
  - 形式上，该算法是在处理一个森林直到最后合并为同一颗树；
  - 实际上过程如$Union/Find$算法来决定边$(u,v)$是否添加还是应该放弃；

#### (3). 深度优先搜索

- 对先序遍历的推广
  - 在处理节点对象之后，再对其邻接节点进行处理；
  - 在处理节点的过程中，通过标记节点是否（$visited =  true$）被访问过来防止圈的出现；
  - 如果图是无向且不连通的，或是有向的但非强连通的，通过标记访问过的节点有可能无法访问到某些节点；

- **深度优先生成树（无向图）**

  - 该树的根为第一个被访问的节点；
  - 图中的每一条边$(v,w)$都在树上被表示出来；
  - 在处理$(v,w)$边时，发现$w$是未被标识时，就在树上画出$(v,w)$边；
  - 在处理$(v,w)$边时，发现$w$是已被标识时，而处理$(w,v)$时$v$·也有标识，则画一条**背向边**（虚线）来表示该条边；
  - 处理非连通图时，在处理所有节点的过程中会生成多棵树，该树的集合就是**深度优先森林**；

- **双连通性**
  - 具有双连通性的图：图中不存在被删除之后就会使得图变得不再连通的顶点的图；
  - **割点**：不具有双连通性的图中，删除会使得图失去连通性的点；
  - 寻找割点的算法
    - 在执行优先搜索过程之中，顶点按照被访问顺序进行编号（$num(v)$）；
    - 对于深度优先搜索生成树上的每一个顶点$v$，计算编号最低的顶点，称为$low(v)$，从该点出发然后通过树的零边或多条边以及背向边返回回来的点；
    - 一个圈中背向边所指向的节点；
    - 当根有多于一个儿子时，他一定是割点；
    - 当根只有一个儿子时，当且仅当存在某个儿子$w$使得$low(w) \ge Num(v)$；

- 深度优先搜索与寻找割点结合的实现

  ```java
      /**
       * 深度优先搜索实现
       */
      public void findArt(Vertex<T> vertex, int count) {
          vertex.know = true;
          vertex.low = vertex.num = count ++;
  贿赂
          for (Edge<T> edge : vertex.edges) {
              Vertex<T> w = edge.v;
              if (w.know != true) {
                  w.path = vertex;
                  findArt(w, count);
                  
                  if (w.low >= vertex.num) {
                  	 System.out.println(vertex + "是割点");
                  }
               
                  vertex.low = Math.min(vertex.low, w.low);
              } else if (vertex.path != w) {
                  
                  vertex.low = Math.min(vertex.low, w.num);
              }
          }
      }
  ```

- **欧拉回路**

  - 欧拉回路就是一个经过途中每条边的次数唯一的圈；
  - 欧拉回路的起点和终点为同一个点；
  - 只有当图连通且每个顶点的入度都为偶数时才存在欧拉环路；
  - 实现方式
    - 采用多次寻找不同的环进行拼接的方式实现；
    - 使用链表记录每次寻找的环，最后拼接成完整的环；

- 有向图

  - 在不是强连接的有向图中，反复对未标记节点进行深度优先搜索，直到所有节点都被访问结束；
  - 不通向新顶点的三种类型边
    - 背向边；
    - **前向边**：从树的一个节点通向同一个后裔；
    - **交叉边**：将两个不相关的树节点连接起来的边；

### 5. 算法设计技巧

#### (1). 贪婪算法

- 简单调度问题
  - **非预占调度**：一项任务一旦开始，中途不会停止直到其完成；
  - 任务完成平均时间的最小化问题；
  - 通过优先执行需要时间短的任务，来达到任务完成时间的最短化；
  - 在**多处理器**的情况下，当$0\leqq i < N/P$时，将按时间排序的$j_{iP+1} \backsim  j_{(i+1)p}$中的每一个任务放在不同的处理器上来得到最优平均完成时间；
- 哈夫曼编码
  - 哈夫曼编码主要是用来进行**文件压缩**；
  - **$trie$树**
    - 用来表示字母二进制代码的二叉树；
    - 树只有叶子上有数据，同时每个字符从根节点开始用0来表示左分支，而用1来表示右分支；
    - 当字符$c_i$在深度$d_i$处出现$f_i$次，则该编码的值就等于$\sum d_i f_i$；
    - 通过**换行（$newline$）**，即是将只有一个儿子的子树的儿子替换其父节点来进一步优化$trie$树；
  - **前缀码**：没有字符代码是别的字符代码的前缀；
