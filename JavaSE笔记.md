第一章 Java开发坏境搭建

1、常用的dos命令：

	* 打开dos 命令窗口：

		- win键+r-->输入cmd-->回车

	* 常见的Dos命令：

		- mkdir abc 创建abc目录；
		- del 删除一个或多个文件（支持模糊匹配）；
		- exit 退出当前Dos命令窗口；
		- cls 清屏；
		- DOS窗口中的任意位置，点击鼠标右键，然后选择标记，选择需要复制的内容；
		- dir 列出当前目录下所有文件目录；
		- 切换盘符：

			* c：回车 
			* d：回车
			* e：回车
			* f：回车

		- cd 命令表示：change directory（改变路径）

			* 但是路径包括绝对路径和相对路径；
			* 绝对路径：表示该路径从某个磁盘盘符下作为出发点的路径；
			* 相对路径：表示该路径从当前所在文件夹作为出发点的路径；
			* 假设当前所在路径为C:\users\Administrator,那么此时输入cd Desktop，那么其中Desktop就是相对路径；
			* 假设当前所在路径为cd C:\users\Administrator\Desktop，那么其中
			C:\users\Administrator\Desktop就是绝对路径；

		- cd ..：回到上级目录；
		- cd \ ：回到根目录；
		- ipconfig ：查看本台计算机的ip地址；

			*添加/all：查看更详细的信息；

		-ping ：查看两台电脑或与网站是否能通信；

			*添加-t ：一直ping 查看网络是否稳定；

		- ctrl+c：终止一直进行中的命令

2、常用快捷键

	* 回到行首： home键；
	* 回到行尾： end键；
	* 选中某一行

		- 光标在行尾：shift+home
		- 光标在行首：shift+end

	* 回到文件头：Ctrl+ home；
	* 回到文件尾：Ctrl+ end；
	* 选中一个单词：
		
		- 双击鼠标；
		- ctrl + shift + 右箭头/左箭头；

	* 选中一行：三击鼠标；

3、JAVA开发工具包：现阶段Java8/JDK1.8/JDK8

	*JAVA包含三大块：

		- JavaSE(Java标准版)
		- JavaEE(Java 企业版)
		- javaME(Java 微型版)
		其中JavaSE是基础，主攻方向为JavaEE

4、Java加载与执行

	* Java程序的运行包括两个非常重要的阶段
		-编译阶段
		-运行阶段

	* 编译阶段

		- 编译阶段主要的任务是检查Java源程序（xxx.java）是否符合Java语法，
		符合Java语法则能生成正常的字节码文件（xxx.class）；

		- 过程：新建必须符合java语法规则的xxx.java的源程序，
		然后在Dos窗口中使用javac.exe命令对java程序进行编译生成
		xxx.class字节码文件（可能生成多个）。

	* 运行阶段	

		- System.out.print(输出不换行)；
		- System.out.printLn(输出换行)；
		- 在Dos窗口中使用java.exe命令对java程序进行运行；

5、第一个Java程序(Hello World)

	*javac程序不可用解决方法：
		- windows 操作系统首先会从当前目录下搜索命令；
		- 再从环境变量path指定的路径目录中去搜索该命令。

	*javac程序的使用方法：
		- javac java 源文件路径
			*相对路径和绝对路径都可以。
	
	*java程序的使用方法：
		- java 类名（不能是路径，类名不带.class）；

		- 使用步骤：

			*第一步：先使用cd命令切换到类所在路径；
			*第二步：再使用java.exe运行程序；
	
第二章 标识符与关键字

	-标识符
		
		* 标识符是java源程序中黑色字体单词；
			
			- 程序员有权利其命名的单词
			- 包括：类名、方法名、变量名、常量名、接口名；

		* 标识符的命名规则：

			- 标识符只能由数字、字母、下划线、美元符号组成
			- 不能以数字开头；
			- 不能以关键字作为标识符；
			- 严格区分大小写；

		* 标识符的命名规范：

			- 遵循驼峰命名方式：单词与单词之间很好的进行分隔；
			- 类名、接口名：首字母大写、后面每个单词首字母大写；
			- 方法名、变量名：首字母小写、后面每个单词首字母大写；
			- 常量名：所有字母大写，单词之间使用下划线_进行衔接；

	- 关键字
		
		* java开发时，sun公司定义的特殊含义的单词；
		* 在editplus中用蓝色标出来的字符；
		* 关键字全部都是小写；

第三章 变量
		
	- 字面量

		* 整数型字面量： 整数；
		* 浮点型字面量：小数；
		* 布尔型字面量：true 和 false 没有其他值了；；
		* 字符型字面量：‘a’、'b'、‘中’；
		* 字符串型字面量：“abc”、“中国”；
		* 字符型与字符串都是描述现实世界的文字，字符型只能用单引号括起来；
		* 所有字符串型只能用双引号括起来；
		* 只有单个字符才能称之为字符型；
		* 字符型与字符串型的区别方法；
			
			- 主要看是双引号还是单引号；
		
	- 变量；
			
		* 变量是内存当中存储数据的最基本单元；
		* int 是整数型数据类型；
		* 不同的数据类型在内存中分配的空间大小不同；
		* 对于一个变量来说包括三要素：
				
			- 变量的数据类型；
			- 变量的名称；
			- 变量保存的值；

		* 变量的申明：数据类型 变量名

			- int 整数型数据；
			- double 浮点型数据；
			- String 字符串；
			- char 字符型；

		* 变量必须先申明，再赋值；
		* 变量的赋值：使用 = 右边先执行，然后赋值给左边；
		* 在同一个域中，变量名不能重复定义；
		* 一行可以生成多个变量；
		* 变量的分类
				
			- 方法体当中声明的变量：局部变量；
			- 方法体外声明的变量：成员变量；
			
		* 变量的作用域

			- 变量的有效范围就是变量的作用域；
			- 变量的作用域出了大括号就不认识了；
			- java中的就近原则：那个离得近就访问哪个；

第四章 数据类型

	- 数据类型用来声明变量：
		
		* 在运行过程之中不同数据类型分配的空间不同；

	- 数据类型种类：

		* 基本型数据类型：
			
			- 第一类：整数型
				
				* byte（默认值0），short（默认值0），int（默认值0），long（默认值0L）

			- 第二类：浮点型

				*float（默认值0），double（默认值0）；

			- 第三类：布尔型
				
				* boolean（默认值false）：true 和 false

			- 第四类：字符型

				* char（默认值\u000）
			
			- 数据类型占用空间量：

				* byte： [-128~127]1字节；
				* shrot： [-32768~32767]2字节；
				* int： [-2147483648~2147483648]4字节；
				* long： 8字节；
				* float：4字节；
				* double：8字节（精度更高）；
				* boolean：1字节；
				* char：[0~65535]2字节；

			- 十进制转换为二进制：
				
				* 除以2，然后逆序输出；

			- ASCII码：英文编码，1byte存储单位；

				- ‘a’――――>97；
				- ‘A’――――>65；
				- ‘0’――――>48；

			- 编码方式：ASCII，ISO-8859-1(LATIN-1)，GB2312，GBK，GB18030，Big5，unicode；
		
		* 数据类型详解
			
			- 字符型char
				
				* 可以存储一个汉字；
				* 转义字符：两个字符组合在一起表示一个字符；
					
					- \t: 制表符tab，相当于键盘上tab；
					- \n: 换行符；
					- \: 将相邻的特殊字符转义为普通字符；
					- \u: 表示后面字符的unicode编码（16进制）；
					- \r: 回车
					；

				* 当一个整数赋予char型，会自动转换为字符；
				
			- 整数型
				
				* 八进制：以0开始；
				* 十六进制：以0x开始；
				* 二进制：以0b开始；
				* 任何情况下，整数型字面量被默认当做int类型处理，需要当做long处理，需要加上L；

			- 强制类型转换

				* 强制类型转换符：(小容量数据类型)；
				* 将大容量数据赋予小容量需要加强制类型转换符；
				* 但是该方式有可能造成精度损失；
				
			- int类型和int类型运算的最终结果还是int类型；
			- 浮点型
				
				* 任意一个浮点型数都比long大；
				* 任意一个浮点型数都被当做double来处理；
				* 需要被当成float数据时，须在数据后面加上F；

			- boolean 类型
				
				* 在程序开发中常放在逻辑判断中，通常放在条件上
		
	- 数据类型转换规则
			
		* 除了boolean类型外，都可以互相转化；
		* 整数字面量没超过取值范围时，可以直接转换为byte、short、chart；
		* 小容量向大容量转换成为自动类型转换；容量大小排序为byte<short(char)<int<long<float<double;
		* 大容量转化为小容量必须添加强制类型转换符；
		* char、short、byte做混合运算的时候，是先转换为int再运算的；
		* 多种数据类型做混合运算时，最终结果类型是最大结果类型；

第五章 运算符
	
	- 算术运算符
		
		* ++ 自加1：

			- 可以出现在变量前与变量后，执行完都加1；
			- 当++出现在变量后，先做赋值运算，再自加1；
			- 当++出现在变量前，先自加1，再做赋值运算；

		* -- 自减1；
		* %  求余数；

	- 关系运算符

		* >，<，=，==，!=，>=，<=；
		* ==是判断两边变量是否相等的；
		* 所有关系运算符结果都为boolean；

	- 逻辑运算符
		
		* &(逻辑与：并且)，| (逻辑或：或者)，!(逻辑非：取反),||(短路或)，&&短路与； 
		* 两边都是boolean类型，运算结果也是boolean类型
		* 短路与&&
			
			- 与逻辑与&运算结果没有任何区别；
			- 短路现象：当使用短路与&&时，当左边表达式为假，右边表达式不执行；
			- 一般使用短路与&&；

	-赋值运算符
		
		* 基本赋值运算符：=；
		* 扩展赋值运算符：+=，-=，*=，/=，%=；

			- +=：追加（m+=k：m=（m的数据类型）m+k）；
			- 使用扩展运算符时，永远不会改变运算结果数据类型；

	- 条件运算符（三目运算符）
		
		* 语法格式：布尔表达式？表达式1:表达式2；
		* 执行原理：布尔表达式为真，表达式1为运算结果，布尔表达式为假，表达式1为运算结果；

	- + 字符串拼接功能：运算符两边任意一边是字符串类型，这个+会自动进行拼接操作；
	- 位运算符
	
		* >> x ：二进制位右移x位（缩小2的x次方倍）
		* << x : 二进制位左移x位（增加2的x次方倍）


第六章 控制语句

	- java 中怎么接收键盘的输入；
		
		* java.util.Scanner s = new java.util.Scanner(System.in);//定义键盘扫描器，s是变量名，能够修改。
		  int i = s.nextInt();//i变量就是接收的键盘数据。

	- 选择语句（分支语句）

		* 所有合法的控制语句之间是可以嵌套的；		
		* IF语句

			- 语法格式
				
				* 第一种写法：if（布尔表达式）{java语句}（如果布尔表达式结果为真，java语句执行，否则不执行）；
				* 第二种写法：if（布尔表达式）{java语句1}else{java语句2}（如果布尔表达式结果为真，java语句1执行，否则java语句2执行）； 
				* 第三种写法：if（布尔表达式1）{java语句1} else if （布尔表达式2）{java语句2}else if （布尔表达式3）{java语句3}（如果布尔表达式1结果为真，java语句1执行，如果布尔表达式2结果为真，java语句2执行，如果布尔表达式3结果为真，java语句3执行）； 
				* 第四种写法：if（布尔表达式1）{java语句1} else if （布尔表达式2）{java语句2}else if （布尔表达式3）{java语句3}else（java语句4）（如果布尔表达式1结果为真，java语句1执行，如果布尔表达式2结果为真，java语句2执行，如果布尔表达式3结果为真，java语句3执行）； 
			
			- if语句只能执行一个分支，不可能多个执行；
			- 只要有一个分支执行了语句就结束了；
			
		* switch语句
			
			- 语法格式
				
				* swith（值）{case 值1：java语句；java语句；break；case 值2：java语句；java语句；break；default：java语句；}
				* break；语句不是必须的；default分支也不是必须的；
				* switch本质上只支持int与String；byte，short，char可以进行自动类型转换来运行；
				* switch语句中值使用“==”进行比较；
			
			-执行原理

				* 那“值”与“值1”，“值2”进行比较，相同时执行相应的分支java语句；
				* 如果没有“break”，会发生case穿透现象；
				* 所有分支都没有执行后，会执行default分支；
				
			- 支持枚举类型（enum），String，int
		
	- 循环语句

		* for 循环：

			- 语法格式：for（初始化表达式；更新表达式；更新表达式）{java语句（循环体）}；
			- 初始化表达式最先执行，整个循环过程中只执行一次；
			- 条件表达式的结果必须是布尔类型；
			- 执行原理：先执行初始化表达式，然后判断条件表达式的结果，结果为真时执行循环体，随后执行更新体，更新完之后在判断，指导判断表达式结果为假；
			- 初始化表达式，判断表达式，更新表达式都不是必须的；
		
		* while 循环

			- 语法格式：while（布尔表达式（判断））{循环体；}
			- 执行原理；判断布尔表达式结果，为真执行循环体，再判断，直到为假；
			- for和while可以完全互换；

		* do.....while 循环

			- 语法格式：do{循环体；}while（布尔表达式（判断））；
			- 执行原理：先执行循环体，再进行判断；
			- do....while循环最后不要漏掉分号；
			- 对于do...while来说循环体执行的次数最小为1，其他两种方式最低为0；

	- 转向语句

		* break 语句

			- break与continue语句一样，都是一个单词成为一条语句；
			- 使用的地方
				
				* switch语句之中，用来终止switch语句的执行，防止case穿透；
				* 用在循环语句之中，用来终止循环的执行；

			- break语句不会终止方法，只会让离他最近的循环终止；
			- 给循环取名后，然后再终止指定的循环；

		* continue 语句

			- continue 作用是终止当前本次循环，直接（执行更新表达式）进入下一次循环继续执行；
			- for（）{if(){continue;}code1;code2;} continue一旦执行，后面code1，code2代码直接不执行了，直接进入下一轮循环；

		* return 语句

			* 控制方法的结束；
						
第七章 方法
	
	- 语法格式：[修饰符列表] 返回值类型 方法名（形式参数列表）{方法体；}（[]里面的内容不是必须的）；
	- 修饰符列表：非必选项；
	- 返回值
			
		- 返回值类型：java中所有的数据类型；
		- 返回值：一般指的是方法执行结束后的结果；一般是一个数据；
		- 不返回值时，返回值类型写上void；
		- 需要返回值时，最后需要必须加上”return 数据“语句；
		- 只要“return”关键语句执行，当前方法必定结束；
		- 有“void”，不能加“return 数据”，但可以有“return”；

	- 方法名
		
		* 方法名见名知义（驼峰原则）；
		* 首字母大写，后面小写；

	- 形式参数列表

		* 简称：形参；
		* 形式参数列表中的每个参数都是“局部变量”，方法结束后释放内存；
		* 形参的个数是“0~n个”；
		* 多个形参之间用“逗号，”隔开；
		* 数据类型起决定性作用，形参对应的变量名是随意的；

	- 方法体

		* 编写的是业务逻辑；
		* 方法体中要使用形参；

	- 方法的调用

		* 语法规则：类名.方法名（实际参数列表）；
		* 实参和形参的类型和个数需要一一对应；
		* 使用变量来接收返回值：数据类型 a = 类名.方法名（实际参数列表）；
		* 跨类调用方法时类名不可省略；
		* 调用同一个类中的方法类名可以省略；
		* 方法调用时需要的空间是在栈空间分配的；
	
	- 方法的重载

		* 在同一类之中，多个功能相似，可以考虑使用相同的方法名；
		* 方法重载发生条件：
			
			- 在同一类之中；
			- 方法名不同；
			- 参数列表不同；

		* 方法重载和方法的返回值与修饰符列表无关；
	
	- 方法的递归

		* 方法自己调用自己就是方法递归；
		* 递归中，没有结束条件，一定会发生栈溢出；

第八章 面向对象
	
	- OOA：面向对象分析；
	- OOD：面向对象设计；
	- OOP：面向对象编程；
	- 面向对象的三大特征：封装、继承、多态；
	- 类与对象
		
		* “类”是抽象概念（特征的总结）或者是模板，“对象”是实际存在的个体；
		* “对象”是通过“类”创造出的个体；
		* “对象”又可称为“实例”；
		* 实例化：通过类创造对象的过程；
		* 抽象：抽取多个相同对象的共同特征的过程；
		* 类----->[实例化]----->对象；
		* 对象---->[抽象]------>类；
		* 类 = 属性 + 方法；
		* 属性描述状态：多见于名词；
		* 方法描述动作：多见于动词；
	
	-类的定义：
		
		* 语法格式：[修饰符列表] class 类名{类体 = 属性 + 方法，属性在代码上以“变量”的形式存在}；
		* 方法体内生成的变量：局部变量；方法体外生成的变量：成员变量（属性）；
		* 局部变量不赋值不能使用；
	
	- java 中所有的类都是引用数据类型；
	- java 内存
	
		* 栈：方法只要执行，会压栈（存储局部变量）；
		* 堆；new出来的对象都在堆中，垃圾回收主要针对无指针指向的对象（存储实例变量）；
		* 方法区：类的信息，字节码信息，代码片段（存储静态变量）；


第九章 对象的创建与使用

	- 创建对象

		* 语法：类型 变量名 = new xx(类名)；
		* 使用xx类模板创建新对象；

	- 凡是new运算符创建的对象，都存在堆内存中；
	- 栈主要存储局部变量；
	- 成员变量未手动赋值时，都是系统赋予默认值；
	- 实例变量就是对象里面的变量；
	- 不能通过类名来访问实例变量；
	- 指向堆内存中存储对象地址的变量叫做引用；
	- 访问实例变量

		* 语法：引用.实例变量名；
		* 给实例变量赋值：引用.实例变量名 = 数据；
	
	- 赋值运算是将等号后中数据存储的内容复制一份给等号前数据；
	- 空指针异常

		* 只有在空引用访问实例相关内容，就会出现空指针异常；

	- 方法调用时数据传递原理和赋值的原理是一致的；
	- 构造方法
		
		* 定义：构造方法是用来创建对象同时给对象属性（实例变量）赋值；
		* 构造方法是使用new运算符来调用的；
		* 当一个类没有提供任何构造方法，系统会默认提供一个无参数的构造方法（缺省构造器）；
		* 语法结构：[修饰符列表] 构造方法名（形式参数列表）{构造方法体}
			
			- 构造方法名和类名必须一致；
			- 构造方法不需要指定返回值类型；
			- 现阶段构造方法修饰符列表写public；
		
		* 如果存在有参数的构造方法后，系统不会提供默认的无参数的构造方法了；
		* 当构造方法中没有给成员参数手动赋值时，系统会默认在构造方法中给参数赋默认值；

	- 封装

		* 将一个系统聚合成一个整体，只留部分操作窗口以供操作；
		* 封装的作用：
			
			- 保证内部结构的安全；
			- 屏蔽复杂，暴露简单；
		
		* 访问一个数据的属性，包含两种操作；
			
			- 读取数据（get）；
			- 修改数据（set）；

		* 封装的方法；

			- 在定义数据时，使用private（只有在本类中可以访问，外部不能访问）修饰符对数据类型进行修饰从而实现数据的私有化；
			- 对外提供公开的set方法与get方法设置操作入口：

				* set方法与get方法都应该是实例方法（不应该带static）；
				* 规范格式：
					
					- get 方法：public 返回值类型 get+属性名（）{return xxx}
					- set 方法：public void set+属性名（数据参数）{xxx = 数据参数}
			
			- 在 get与set方法中设置关卡；
				
			- 实例方法（对象级别的方法）

				* 不带static的方法；
				* 调用的方式：使用new创建引用 ----> 使用“引用.”的方式进行访问； 
				* 实例方法的调用也需要有对象的存在；
		
第十一章 static 和 this
	
	- static 关键字
		
		* static 翻译为“静态的”
		* 所有static关键字修饰的都是类相关的，类级别的；
		* 所有static修饰的，都是采用“类名.”的方式访问；
		* static修饰的变量：静态变量；
		* static修饰的方法：静态方法；
		* 静态变量在类加载时初始化，且存储在方法区；
		* 静态变量为类的共有属性
				
	- 实例变量与静态变量
	
		* 成员变量可以分为实例变量与静态变量；
		* 实例级别的方法或变量一定需要引用来访问；
		* 类级别的方法或变量可以通过引用和类名.的方式访问；
		* 定义变量的时机
		
			- 实例方法：方法体中直接访问了实例变量的方法就是实例方法；
			- 静态方法：工具类当中的方法，一般都是静态的；
			
	- 静态代码块
		
		* 语法：static{代码}；
		* 特点：在类加载时执行且只执行一次；
		* 静态代码块自上而下执行且在main方法加载之前执行；
		* 静态代码块是sun公司为程序员提供的类加载时机（写日志）；
		
	- 实例语句块
	
		* 语法：{语句}；
		* 实例语句块在构造方法时机执行前执行；
		
	- this关键字
	
		* this是一个变量，是一个引用；
		* this是存储在堆内存对象之中，并且存储了一个自身位置的变量；
		* this可以使用在实例方法中，this指向当前对象（谁调用了方法，this就是谁）；
		* this 大部分时候是可以省略的；
		* 在实例方法或构造方法中为了区别局部参数与实例参数时不能省略；
		* this还可以用在构造方法中。
			
			- 通过当前构造方法去调用本类中的另一个构造方法语法格式：this（实际参数列表）；
			- 可以做到代码复用；
			- this（）只能出现在构造方法第一行；
			
	- 所有实例相关的，都需要先创造对象，在通过“引用.”的方式访问；
	- 所有静态相关都是“类名.”来访问；

第十二章 继承extends
		
	- 语法结构：class 子类（扩展类、派生类） extends 父类（基类、超类）；
	- 继承以后子类拥有父类除构造函数和private修饰的数据以外所有代码；
	- 继承的作用
	
		* 基本作用：子类继承父类，代码可以复用；
		* 主要作用：有了继承关系，才有后期的方法覆盖和多态；
		
	- 继承的相关特性
	
		* java 只支持单继承不支持多继承；
		* java可以通过间接继承的方式实现多继承；
		* 当没有显示继承任何类时，则继承object类（根类）；
		* 继承会导致子类与父类之间耦合度增高；
		
第十三章 方法覆盖和多态

	- 方法覆盖使用时机：当父类中的方法无法满足子类的需求时，需要利用方法覆盖对子类的方法进行优化；
	- 方法覆盖就是将继承过来的方法覆盖掉；
	- 方法覆盖构成条件
	
		* 存在类的继承
		* 覆盖的方法与原方法除方法体外应全部一致；
		* 访问权限不能更低，可以更高；
		* 覆盖之后的方法不能比之前的方法抛出更多的异常；
		
	- 方法覆盖的注意事项
	
		* 方法覆盖只针对方法不针对属性；
		* 私有方法不能被覆盖；
		* 构造方法不能被继承，所以构造方法不能被覆盖；
		* 方法覆盖只针对实例方法，不针对静态方法；
		* 方法覆盖时 最好将原方法复制重写；
		
	- 多态的基础语法
	
		* 编译阶段为静态绑定，运行阶段为动态绑定；
		* 多态即为动态绑定阶段与动态绑定阶段存在差异；
		* 向上转型和向下转型的类之间应该有继承关系；
		* 向上转型：将子类转为父类（自动类型转换）；父类 变量名 = new 子类；
		* 向下转型：将父类转为子类（强制类型转换，需要加强制类型转换符）；子类 变量 = （子类）已经向上转型的变量；
		
			- 当需要访问的方法是子类中特有方法需采用向下转型； 
			- 强制类型转换可能出现类型转换异常（java.lang.ClassCastException）
			
		* instanceof运算符（运行阶段动态判断向下转型是否存在问题）
			
			- instanceof可以再运算阶段判断引用指向的对象类型；
			- 语法结构：引用 instanceof 类型；
			- 运算结果类型为boolean类型；
			- 结果为true，表示引用指向的对象为对应类型；
			- 结果为false，表示引用指向的对象非对应类型；
			- 在向下转换时，都需要运行instanceof运算符进行判断；
			
	- 多态在开发中的应用
	
		* 降低程序的耦合度，提高程序的扩展度；
		* 面相抽象编程，不建议面向具体；
		
	- 软件开发的七大原则；
		
		* 开闭原则（ocp）：对扩展开放（能够额外添加），对修改关闭（能最少的修改现在的代码）；
		
	- super 关键字
	
		* super 能出现在实例方法和构造方法中；
		* super的语法格式为“super.”,"super()";
		* super不能使用在静态方法中 ；
		* 不能省略super.的情况：
		
			- 当父类和子类中存在同名属性或方法时，子类中访问父类的同名属性或方法时“super.”不能省略；
		
		* super（实参）
		
			- 只能出现在构造方法的第一行，通过当前构造方法去调用“父类”中的构造方法；
			- 目的是：创建子类对象的时候，先初始化父类型特征。
			- 子类构造方法第一行默认执行super（）；
			- super不是引用，不保存内存地址，不指向任何对象，只代表当前类的父类特征；
			
	- 退出java虚拟机，System.exit（0）；
	
第十四章 IntelliJ工具
		
	- 快速生成main方法：psvm；
	- 快速生成System.out.println：sout；
	- 删除一行 ctrl+y
	- 列表左箭头关闭，右箭头关闭；
	- 任何新增新建添加快捷键 alt+instrt
	- 窗口变大变小ctrl+shift+f12；
	- 单行注释ctrl+/；多行注释ctrl+shift+/
	- 复制一行为ctrl+d；
	- 纠正错误：alt+enter
	- IF（i == Null）：IFn
		
第十五章 面向对象2

	- final 关键字
	
		* final 表示最终的不可变的；
		* final 修饰的类无法被继承；	
		* final 修饰的方法无法被覆盖重写；
		* final 修饰的变量只能被赋值一次；
			
			- final 修饰的局部变量（包含引用）只能被手动赋值一次；
			- final 修饰的实例变量必须直接手动赋值（也可以构造方法中赋值）；
			- final 修饰的实例变量与static关键字联合使用；
			- static final 修饰的实例对象叫做常量，和静态变量一样在类加载时初始化，存储在方法区；
			- 常量一般都是公开的；
			
	- 抽象类和接口
	
		* 抽象类
			
			- 抽象类是将具有共同特征的类进一步抽象所形成的类；
			- 语法：[修饰符列表] abstract class 类名{类体}
			- 抽象类无法创建对象；
			- 抽象类是用来被继承的；
			- 抽象方法：没有方法体的方法；
			
				* 没有方法体， 以分号结尾；
				* 修饰符中有abstract；
				
			- 抽象方法必须存在于抽象类中；
			- 非抽象类继承抽象类时，必须将抽象类中的抽象方法覆盖重写了（抽象的实现）；
			- 抽象的父类 引用 = new 子类（面向抽象编程）；
			
		* 接口
			
			- 接口的基础语法：
			
				* 接口是一种引用数据类型；
				* 接口是完全抽象的，（抽象类是半抽象的）；
				* [修饰符列表] interface 接口名{}；
				* 编译之后也是class文件；
				* 接口支持多继承；
				* 接口中只包含常量与抽象方法；
				* 接口中的抽象方法定义时public static 可以省略；
				* 常量的public static final 也可以省略；
				* 类和类之间叫继承；类与接口之间叫实现（使用implements关键字完成）；
				* 一个类可以同时实现多个接口；
				* 调用其他接口中的方法需要接口转型；
				* 继承与实现同时出现时，
				
					- extends在前，implement在后；
					- 创建对象时，父类为接口名：
					
				* 接口通常提取的动作；
			
			- 接口在开发中的作用
			
				* 类似多态在开发中的作用；
				* 接口可以大大提升程序的扩展力；
				* 任何一个接口都有调用者和实现者；
				* 解耦合；
			
			- 类与类之间的关系；
			
				* is a ：凡是能满足"is a"关系表示"继承关系"；
				* has a：凡是能满足"has a"关系表示"关联关系"，通常以属性的形式存在；
				* like a：凡是能满足"like a"关系表示"实现关系"，类实现接口；
				
			- 抽象类与语法的区别；
			
				* 抽象类中有构造方法，接口中没有构造方法；
				* 类之间只能单继承，接口之间可以多继承；
				* 接口中只允许出现常量与抽象方法；
				* 接口一般对“行为”的抽象；
			
			- package 和 import 机制
			
				* package的使用

					- 不同的package具有不同功能，存储不同功能的类；
					- 语法：package ”包名“；
					- package 语句只允许出现在java源代码的第一行；
					- 命名规范：公司域名倒叙+项目名+模块名+功能名；
					- 带有package的Java程序
					
						* 编译：javac -d.源代码名；
						* 运行：java 类名（带包名）；
				
				* 关于import的使用；
				
					- import 类名（带包名）：将需要使用的类导出来；
					- A类中使用B类
						
						* 这两类在同一个包中，不需要加import；
						* 这两类不在同一个包中，需要加import；
						
					- import语句只能出现在package语句下面以及class的上面；
					- java.lang包下的类不需要导入；
		
		* 访问控制权限
		
			- peivate（私有）；protect（受保护的）；public（公开的）；空白 为默认的；
			- public：所有位置都能访问；
			- protect：只能在本类，同包，子类中访问；
			- 默认的：只能在本类，同包下访问；
			- private：只能在本类中访问；
			- 范围从大到小排序：public > protect > 默认 > private;
			
	-java 类库中自带的方法

		* object 类中的方法
			
			- String toString()方法;
				
				* 默认实现： 类名@对象的内存地址转化为十六进制的形式；
				* 目的：将一个java对象转化为字符串的形式；
				* 建议将toString方法重写（简洁， 详实， 易阅读），
				* 输出引用的时候，会默认调出引用的toString方法；
				
			- boolean equals（）方法：
			
				* 默认实现：判断两个对象是否相等；
				* 在object中是使用“==”（判断两对象内存地址是否相等）判断两个对象是否相等；
				* 在使用需要结合实际需要进行重写；
				* java 基本数据使用“==”判断两个对象是否相等；
				* java 引用数据使用“equals方法”判断两个对象是否相等；
				* 重写equals方法要彻底；
				
			- protected void finalize();
			
				* 源代码中只有一个方法体，里面没有代码；
				* JVM垃圾回收器自动调用该代码，不需要手动调用；
				* 该代码是sun公司提供的一个垃圾回收的时机，该方法会在该时机使用；
				* java中的垃圾回收器有可能不启动；
				* 建议垃圾回收器启动代码：System.gc（）；
				
			- int hashCode（）
			
				* 返回值为代表对象的内存地址的哈希值；
	- 内部类
	
		* 定义：在类的内部再定义一个类；
		* 分类：
		
			- 静态内部类：类似静态变量；
			- 实例内部类：类似实例变量；
			- 局部内部类：类似局部变量；
			- 匿名内部类：没有名字的局部内部类；
		
第十六章 数组

	- 数组的基本信息
	
		* 数组是一种引用数据类型（数据类型[]）；
		* 数组是个能同时容纳多个数据的容器（数据的结合）；
		* 数组中可以存储基本数据类型与引用数据类型的数据；
		* 数组对象是存储在堆内存之中；
		* 数组之中存储的是“对象”的时候存储的是对象的引用（内存地址）；
		* 数组一旦创建，在java中，长度不变；
		* 数组的分类：一维数组，二维数组，多维数组；
		* 所有数组都具有length属性，用来获取数组中的元素个数；
		* 数组中存储的元素数据类型必须统一；
		* 数组中元素的内存地址是连续的；
		* 数据结构其实是种简单的数据结构；
		* 数组都是使用第一个元素的内存地址作为整个数组的内存地址；
		* 数组中每个元素都有下标的（从0开始，一次+1）；
		* 数组的优缺点
		
			- 优点：检索效率高，
				
				- 首个数据内存地址知道
				- 每个元素类型相同，占用空间相同；
				- 每个元素内存地址连续；
				- 数组存在下标；
				
			- 缺点：
				
				- 随机增删元素时效率较低（要调整后部其余全部元素）；
				- 存储数据量较小（很难找到很大的连续空间）；
				
	- 一维数组
	
		* 声明格式：数据类型[] array;
		* 一维数组的初始化；
		
			- 静态初始化：int[] array = {xx,xx,xx,xx};
			- 动态初始化：int[] array = new int[5];(5表示数组元素个数；初始值为0)；
			
		* 数组中元素的存取；数组名[元素下标]；
		* 当你确定数组中存储数据，可以采用静态初始化；
		* 当你不确定数组中存储数据，采用动态初始化；
		* 直接向函数中传入静态数组时，可以使用" 方法名（new 数据类型[]{xxx,xxx,xxx}）"
		* 主方法中的String[] args数组时接收用户输入的参数（运行后加上的数据）；
		
			- 可以用来验证用户名和密码；
			- 在验证时可以将确定的字符串输入前面，避免空指针异常；
			
		* 一维数组的扩容
			
			- 建一个大数组，然后将小数组内数据拷到大数组中，效率较低；
			- 数组的拷贝
				
				* 语法格式：System.arrayCopy（源数组，拷贝起点，目标数组，存储起点，拷贝长度）
		
	- 二维数组
	
		* 二维数组是每个元素为一维数组的一维数组；
		* 二维数组初始化
			
			- 静态初始化：数据类型[][] 数组名 = {一维数组，一维数组，一维数组}（一维数组中元素个数无限制）;
			- 动态初始化：数据类型[][] 数组名 = new 数据类型[下标][下标]
			
		* 二维数组的length属性是指数组中一维数组的个数；
		* 数组名[下标][下标]：第一个下标是二维数组的下标；第二个下标是一维数组的下标；可以理解为（数组名[下标]）[下标]；
	
	- 数组方法工具类（java.util.Arrays）
	
		* 排序方法（Arrays.sort[]）
		
			-冒泡排序
			
				* 对数组相邻位置进行比较，将大的数据右置；
				* 每次循环之后，都会选出参与比较数字中最大的数据放在右边；
				* 代码
					
					for(int i = 数组名.length; i > 1; i --){
						for(int j = 0; j < i; j ++){						
							if(数组名[j] > 数组名[j + 1]){
								int temp = 数组名[j];
								数组名[j] = 数组名[j + 1];
								数组名[j + 1] = temp;
							}
						}
						
			
			- 选择排序
			
				* 选择排序比冒泡排序效率高；
				* 选择排序是将参与比较的数据中的最小值与最左边数据交换；
				* 寻找一堆数据中最小的，和冒泡排序一致，只是交换；
				* 代码
					
					for(int i = 0; i < 数组名.length; i++){
						int min = i;
						for(int j = i + 1; j < 数组名.length; j ++){
							if(数组名[j] < 数组名[min]) min = j;
						}
						if(min != i){
							int temp = 数组名[j];
							数组名[i] = 数组名[min]
							数组名[min] = temp
						}
						
					}
				
		* 查找方法（Arrays.sort[]）
		
			- 二分法查找算法是基于排序的基础之上；
			- 拿中间元素与被查找元素进行对比；
			
第十七章 java中常用类

	- java.lang.String类
	
		* String 表示字符串类型，属于引用数据类型，不属于基本数据类型
		* 使用“”括起来的String对象是常量，不可变的；
		* “”括起来的字符串都是存储在“方法区”的“字符串常量池”中的；
		* 常用实例函数

			- char charAt（int index）：找出字符串中指定下标处字符； 
			- int compareTo（String anotherString）:比原字符串大输出-1，比原字符串小输出1，与源字符串相等输出：0；
			- boolean contains（CharSequence s）：找出字符串中是否存在s；
			- byte[] getBytes():将本字符串转化为字节数值的形式；
			- int length():算出本字符串的长度；
			- boolean isEmpty():当本字符串length()为0时返回为真；
			- String replace(char oldChar, char newChar): 将本字符串中oldChar替换为newChar；
			- String replaceFrist(String regex, String replaceMent):用replaceMent替换本字符串中第一个出现的regex；
			- int IndexOf(String str): 找出字符串第一次出现处的下标；
			- int lastIndexOf(String str):找出字符串最后一次出现处的下标；
			- String[] split(String regex):将本字符串按照regex标志进行分割；
			- boolean startWith(String prefix):判断本字符串是否以prefix开始；
			- boolean endwith（String suffix）：确认本字符串是否以suffix结尾；
			- String substring(int beginIndex, int endIndex):将本字符串以beginIndex下标开始，endIndex下标结束进行截取；
			- char[] toCharArray():将本字符串转换为char数组；
			- String toLowerCase():将本字符串全转换为小写；
			- String toUperCase():将本字符串全转换为大写；
			- String trim():去掉本字符串前后空白；
			- static String valueOf(数据类型 变量名)：将非字符串类型数据转换为字符串；
			
	- java.lang.Stringbuffer类
	
		* 该类用来进行大量拼接字符串；
		* 优化StringBuffer类的性能；
		
			- 创造一个合适的初始化容量；
			- 减少StringBuffer扩容次数；
			
		* 该类是线程安全的；
			
	- java.lang.Stringbuilder类
		
		* 使用方法和StringBuffer一致；
		* 该类是非线程安全的；
		
	- 包装类
	
		* 8种包装类是属于引用数据类型；父类为Object；
			
			- byte的包装类型：java.lang.Byte；
			- short的包装类型：java.lang.Short；
			- int的包装类型：java.lang.Integer；
			- long的包装类型：java.lang.Long；
			- float的包装类型：java.lang.Float；
			- double的包装类型：java.lang.Double；
			- boolean的包装类型：java.lang.Boolean；
			- char的包装类型：java.lang.Character；
			
		* 拆箱和装箱：
			
			- 装箱(创建引用数据类型对象)：将基本数据类型转换为引用数据类型；
			- 拆箱（基本数据类型 基本数据类型Value(引用数据类型)）：将引用数据类型转换为基本数据类型；
			- 自动装箱和自动拆箱：包装类与基本数据类型能够自动互相转换；
			- ==不会触发自动拆箱机制，只有+ - * /才能够触发；
			- java将[-128~127]之间所有的包装对象提前创建好放在方法区的整数型常量池中去了；
			
		* Intger中常用方法
		
			- static int parseInt(String s);将字符串s转化为int数据类型；
			- static Integer valueOf(int i):将int i转化为Integer数据类型；
			- static int valueInt(Integer i):将Integer i转化为int数据类型；
		
	- 日期

		* Java.util.Date：
		
			- 无参构造方法：获取系统当前时间；
			- Date(long time):获取从1970年1月1日 0时0分0秒0毫秒过time毫秒数的时间；
			
		* java.text.SimpleDateFormate:修改日期格式；
		
			- y：表示年
			- M：表示月
			- d：表示日
			- H：表示小时
			- m：表示分
			- s：表示秒
			- S：表示毫秒；
			- String format(Date date):将日期转化为字符串；
			- Date parse(String):将字符串转化为日期；
	
	- java.lang.System类
	
		* System.out：out为静态变量
		* System.out.println（）
		* System.gc():建议启动垃圾回收器；
		* System.exit(0):退出JVM；
		* System.currentTimeMillis():从1970年1月1日 0时0分0秒0毫秒到现在的总毫秒数； 
		
	- 数字类
	
		* java.text.DecimalFormat：数字的格式化类：
		
			* # 代表任意数字；
			* ，表示千分位；
			* . 表示小数点；
			* 0 表示不够补0；
			
		* java.math.BigDecimal属于大数据，精度极高：用于财会软件中；
		* java.util.random类
		
			- int nextInt（int number）：产生一个在number以前的int类型随机数； 
			
	- 枚举类型enum
	
		* 语法：enum 枚举类型名{枚举值1；枚举值2}
		* 枚举是一个引用数据类型；
		* 枚举中每个值可以看做是常量；
		* 大于两种返回值类型时可以使用枚举；
	
第十八章 异常处理

	- 异常是程序执行过程中的不正常情况；
	- 异常处理机制的作用：提供给程序员参考；
	- 异常可以分为编译时异常与运行时异常；
	
		* 编译时异常指的是需要在编译时必须处理的异常；
		* 运行时异常指的是在编译时可以不做处理的异常；
		
	- 异常的存在形式：
	
		* 异常在java以类的形式存在；
		* 每个异常都能够创建对象；
		
	- 异常处理方式
	
		* 方法申明的位置上使用throws关键字（抛给上一级（调用者））；
		* 用try{..}catch(异常对象){..}语句进行异常的捕捉；
		
			- 出现异常之后，try语句之中异常之后语句不再执行；执行catch；
			- 未出现异常时，只执行try语句；
			- 异常对象中的异常类型可以是准确类型或者父类；
			- catch 可以写多个，在捕捉异常时建议精确一个一个处理；
			- catch遵从从上到下从小到大进行捕捉；
			
		* 一直上抛到main方法中，JVM会终止程序执行；
		* 可以抛出该异常或者该异常的子类；
		* 可以抛出多个异常
	
	- 异常对象的方法
	
		* String getMessage();获取异常对象的简要信息；
		* void printStackTrace():打印异常追踪的堆栈信息（在catch一般都会写）；
		* 异常的追踪应该从上往下一行一行的看；
		
	- finally子句
	
		* finally 语句是最后执行的，并且是一定会执行的；
		* finally子句必须和try一起出现，不能单独编写；
		* finally子句通常用在资源的释放和关闭；
		 
	- UML
		
		* UML是一种统一建模语言，图标式语言
		* UML图中可以描述类和类之间的关系，执行程序的流程，对象的状态的人；
		
	- 异常的定义
	
		* 首先编写一个类继承Exception或RunTimeException；
		* 赋予一个无参构造方法与有参构造方法；
		
	- 异常的使用
	
		* 将方法使用中出现的问题，直接使用“throw new 异常类”手动抛出异常；
		
第十九章 集合

	- 集合是一个容器，可以来容纳其他类型的数据；
	- 集合中存储都是引用(内存地址)；
	- list集合存储元素的特点
	
		* 有序可重复（存储与取出的顺序相同）；
		
	- set集合存储元素的特点
	
		* 无序不可重复（存储与取出的数据可能不相同）；
	
	- Sortedset集合存储元素的特点		
	
		* 无序不可重复
		* 可排序
		
	- Collection接口
	
		* 能存储的元素
		
			- 未使用泛型时，可存储Object的所有子类；
			- 使用泛型之后，只存储特定类型；
			
		* 常用的方法：
		
			- void add（Object e）：向集合中添加元素e；
			- int size（）：获取集合中元素个数；
			- void clear（）：清空集合；
			- boolean contains（Object o）：确认集合中是否包含o元素；
			
				* 底层调用的是equals方法；
				
			- boolean remove（Object o）：移除集合中的o元素；
				
				* 底层调用的是equals方法；
				
			- boolean isEmpty（）：判断集合是否为空；
			- Object[] toArray():将集合转换为一个数组；
			
	- java.util.Collections 工具类; 
	- 集合的遍历和迭代
	
		* 步骤
			
			第一步：获取对象的迭代器（Iterator 迭代器 = 集合名.iteration（））；
			第二步：通过获取的迭代器进行遍历（while（迭代器名.hasNext（）））；
			
		* 迭代器（Iterator）中的方法
		
			- boolean hasNext（）：判断该集合下一空间是否存储有数据；
			- Object next（）：将迭代器指针后移一位，并且取出该位置存储的元素；
			- boolean remove（）：移除迭代器当前指向的元素；
			
		* 集合结构只要发生改变，迭代器必须重新获取；
			
	- 放在集合里面的元素，必须重写equals方法；
	- 迭代过程之中不能使用collection中的remove，可以用Itreator中的remove；
	- List 接口中常用的方法
	
		* void add（int index，Object o）：往集合index下标处加入元素；
		* void set（int index，Object o）：替换集合index下标处元素；
		* Object get（int index）：取出下标index处的元素；
		* int indexOf（Object o）：o出现的最后一次处的索引；
		* void remove（int index）：删除下标为index处的元素；
		
	- ArrayList集合
		
		* 初始容量为10；
		* 集合底层是Object数组；
		* 构造函数
		
			- ArrayList（）；
			- ArrayList（集合容量）；
		
		* ArrayList集合的扩容：每次扩容1.5倍；
	
	- 链表数据结构
		
		* 节点node是单列表中最小的单元；
		* Node中应该还有存储的数据与下一节点的内存地址；
		* 优点：随机增删元素时效率较高；
		* 缺点：查询效率较低，每次查询都要从头开始；
		* LinkList集合是双向链表；
	
	- 集合工具类：java.util.Collections
	- 泛型
	
		* 在集合后加<>来指定集合中存储元素的类型；
		* 自动类型推断：<>中的数据类型不用写，系统可以自动推断；
		* 自定义泛型时<>中的标识符随便写；
		* java常用T与E表示；
			
			- E表示Element；
			- T表示Type；
			
	- 增强for循环
	
		* 语法：for(元素类型 变量名 ： 数组或集合)（）；
		* date代表的是数组中的每个元素；
		
	- Map接口中常用的方法
	
		* V put(K key, V value):添加新的键值对；
		* set<K> keySet():获取map集合中所有的Key；
		* V put(K key)：通过K获取Value；
		* V remove（K key）:通过key删除键值对；
		* int size（）：键值对数量；
		* set<map.Entry<K,V>> entrySet():将map集合转换为set集合:(元素为K=V)
		* boolean containKey（K）：通过K查找map元素；
		* boolean containValue（V）：通过V查找map元素；
		
	- Properties 是一个map集合，key与value都是String类型数据；
		
		* void load（）：加载文件；
		
	- 哈希表
		
		* 哈希表是结合链表和数组；
		* 哈希表底层是一个一维数组；存储元素为单向链表；
		* HashMap集合key部分特点
		
			* 无序：无法确定元素存储的位置；
			* 不重复：再添加时Value会覆盖；
			
		* 散列分布均匀：确保所有元素能平均分配到多个不同链表中；
		* 重写HashCode方法注意事项
		
			- 如果一个类的equals重写时，HashCode也需要重写；
			- 重写后的HashCode和equals判断结果必须相同；
			
		* HashMap初始化容量是16，因子为0.75；
		* hashmap扩容后容量是两倍；
		* HashMap初始化容量必须是2的倍数；
		* HashMap集合K和V都可以为null；
		* Hashtable集合中K和V都不能为null；
	
	- TreeSet集合：
	
		* 无序不可重复，但是可排序；
		* treeset中的元素需实现compareable接口；
		* 需重写compareTo函数；
		* TreeMap与TreeSet采取中序遍历的形式；
		* 使用构造函数时采用比较器（Compareter）的方式；
		* 二叉树
			
			- 自平衡二叉树，遵循左小右大原则存放；
			- 遍历二叉树的三种方式
			
				* 前序遍历：根左右；
				* 中序遍历：左根右；
				* 后续遍历：左右根；
			
第二十章 IO流
	
	- 输入流（InputStream）
	
		* 从硬盘中读取文件放入内存内；
		
	- 输出流（OutStream）
	
		* 从内存读取文件放入硬盘内；
		
	- 按照读取方式进行分类
	
		* 字节流(后缀为Writer或者Reader)：按照字符的方式读取数据（只能读取普通文本）；
		* 字符流(后缀为Stream)：按照字节的方式进行读取（所有文件都能读取）；
		
	- 流使用完后必须关闭（使用close（）函数）；
	- 所有的输出流都是可刷新的，在使用输出流之后都需要使用Flush（）方法；
	- 所有的IO流都在Java.io包下；
	- 文件专属;
		
		* FileInputStream；
		
			- read（）函数的作用与next（）函数作用一致；
			- 未读取到数据时返回-1；
			- IDea默认路径为当前工程根目录；
			- Int（读取到的字节数量） read（byte[] 数组名）：一次最多读取数组名.length长度的字符串
			- int availale(): 返回流当中剩余没有读取到的字节数量；
			- Long skip（long n）：跳过几个字节不读；
			
		* FileOutputStream；
		
			- void write（Bytes[]）：将byte数组全部写入文件中；
			- void write（Byte[],int off, int len）:
			- public FileOutputStream(File file, boolean append):append为真时，在文件后续进行写入；
			
		* FileReader；
		
			- 将字节型输入流中的Byte数组换为char数组；
			
		* FileWriter；
		
			- 将字节型输入流中的Byte数组换为char数组；
			- 可以直接写入字符串；
		
	- 转换流（将字节流转换为字符流）
	
		* InputStreamReader；
		* OutputStreamWriter；
		
	- 缓冲流专属;
		
		* BufferedInputStream；			
		* BufferedOutputStream；
		* BufferedReader；
		
			- 如果一个流的构造参数需要流，则作为参数的流称为节点流；外部流叫包装流或处理流；
			- 节点流自动关闭；只需要关闭最外层包装流；
			- String readline（）：读取一行（不带换行符）；
			
		* BufferedWriter；
		
	- 数据流专属;
		
		* DataInputStream；			
		* DataOutputStream；
		
			- 数据专属流可以将数据与数据类型一并写入文件之中；
			- 写的文件只能使用DataInputStream读取数据；
			- 读取数据的顺序与写入顺序必须一致；
		
	- 标准输出流
			
		* PrintStream；
			
			- 标准输出流不需要手动关闭；
			- void SetOut（PrintStream 变量名）：更改标准输出流方向；
			
		* PrintWriter；
		
	- 对象专属流
	
		* transient 关键字表示游离的，修饰的属性是不参与序列化的；
		* JVM会给实现Serializable接口的类生成一个序列化版本号；
		* 序列化版本号的作用：在类名一致时，区分不同类；
		* 凡是类实现了Serializable接口时，应当手动赋值序列化版本号；
		
			- 加入变量：Private static final long serialVersionUID;
			
		* 序列化Serialize（拆分对象）
		
			- java对象存储到文件中，将java对象保存下来的过程；
			- 参与序列化和反序列化的对象需要实现Serializable接口（标志接口）；
			
		* 反序列化DeSerialize（组装对象）
		
			- 将硬盘数据恢复到内存中java对象；
		
		* ObjectInputStream；
			
			- 将对象序列化；
			
		* ObjectOutputStream；
		
			- 将对象反序列化；
		
	- Flie类
		
		* 可以表示文件路径
		* boolean exists（）：确定文件是否存在；
		* void creatNewFile（）：创造新文件
		* void mkdir（）：创造新路径
		* void mkdirs（）：创造新多重路径；
		* void lastModified（）：获取文件最后修改时间；
		* File[] listFiles(File ):或许该目录下所有子目录；
		
	- 属性配置文件
	
		* 在java一般建议以.properties结尾；
		* #是注释；
		* key 重复的话 value会自动覆盖；
		* Key和Value之间使用=进行连接；
		
第二十一章 多线程

	- 进程与线程
	
		* 进程是一个软件；
		* 线程是一个进程中的执行场景（执行单元）；
		* 现阶段java中最少为两线程并发（main方法和垃圾回收）；
	
	- 堆和方法区是多线程共享；
	- 栈空间为独立的，一个线程一个栈；
	- 单核电脑不能实现真正的多线程并发；
	- 实现线程的方式
	
		* 编写一个类，直接继承java.lang.Thread类，重写run方法；
		
			- 使用Start（）方法开启新的栈空间，该行代码瞬间结束；
			- 随后自动运行run方法，run方法在新栈底部；
			
		* 编写一个类，实现java.lang.Runnable接口，重写run方法（常用）；
		
			- 定义一个可运行的类；
			- 运用Thread类中的有参构造方法创建新线程对象；
			- 使用Start（）方法运行多线程；

			
	- 线程的生命周期
		
		* 启动（start方法启动线程）-->就绪(抢夺CPU时间片的权利)-->(阻塞)-->运行（运行代码）-->死亡（run方法结束）；
		* 在线程的生命周期中就绪与运行相互切换；
		* 阻塞状态是线程在运行状态遇到阻塞事件时进入的状态；解除后进程释放之前的时间片直接进入就绪状态；
	
	- 获取当前线程对象：static Thread currentThread（）
		
		* 在哪个线程之中就获取哪个线程对象；
		
	- 获取线程对象的名字：void setName（String 线程名）
	- 修改线程对象的名字：String getName（）
	- 让当前线程进入休眠：Static void sleep（long millis）：millis是休眠的毫秒数；

		* 可以做到间隔一定时间执行特定的代码；
		* 出现在哪个线程中，哪个线程进入休眠（静态方法和对象无关，自动将对象换成数据类型）；
		
	- 终止线程的睡眠：void interrupt（）；
	- 强行终止线程：在类中定义一个判断，进行手动终止；
	- 线程的调度
	
		* 线程调度模型
			
			- 抢占式调度模型：线程优先级与抢到时间片的概率成正比（java采用）；
			- 均分式调度模型：平均给每个线程分配时间片：
			
		* 线程调度有关方法
		
			- 优先级（概率提升）较高的抢到的时间片相对多一些；
			- void getPriority（）：获取优先级；
			- void setPriority（int num）：设置优先级（默认优先级5，优先级范围1~10）；
			- static void yield（）：暂停当前线程使其进入就绪状态；
			- void join（）：合并线程；（当前线程受阻塞，先执行合并的线程）
			
	- 线程的数据安全
	
		* 不安全的条件
		
			- 多线程并发；
			- 有共享数据；
			- 共享数据存在修改行为；
			
		* 线程安全问题采用线程同步机制（线程排队）来解决；
		* 异步编程模型（多线程并发）
		* 同步编程模型；
		
			- 多个线程的运行之间产生了先后顺序；
			- 线程同步机制语法synchronized（）{同步代码块}；
			- 小括号中填的是需要排队的多线程的共享对象；
			- synchronized就是给对象加上对象锁（一个对象一把锁）；
			- synchronized修饰实例方法上锁的是this；
			- 在静态方法上使用synchronized锁类；
			
		* 数据安全问题的解决方式
		
			- 尽量使用局部变量来代替“实例变量与静态变量”；
			- 考虑多个对象，使得实例变量不共享；
			- 最后才选择synchronized加锁；
			
		* 守护线程（后台线程）
		
			- 垃圾回收线程就是一个守护线程；
			- 守护线程一般是一个死循环；
			- 在用户线程结束时，守护线程自动结束；
			- 在线程启动前调用void setdaemon(boolean true)函数将线程设置为守护线程；
			
		* 定时器
			
			- java.util.Timer：定时器；
		
		* 实现线程的第三种方式
		
			- 实现Callable接口；
			- 该方式可以接收线程返回值；
			- 步骤：
				
				* 创建一个“未来任务类”对象（java.JUC.FutureTask）；
				* call（）方法相当于run方法；
				* 创建线程对象将未来任务类作为实参传入线程内；
				* 使用Object get（）获取线程返回值；
				
			- 优点：可以获取返回值；
			- 缺点：再返回结果时当前方法阻塞，效率降低；
			
	- Object 类中的wait和notify方法；
	
		* void wait（）：让正在本对象上活动的线程进入等待状态同时释放占有本对象的锁，直到被唤醒；
		* void notify（）：将本对象中使用wait（）方法等待的全部线程唤醒；
		* 生产者和消费者模式；
		
第二十二章 反射机制

	- Class文件指向方法区中的字节码；
	- 反射机制可以操作字节码文件；
	- 相关的类（在java.lang.reflect包下）
		
		* java.lang.Class：代表整个字节码文件；
		* java.lang.reflect.Method：代表字节码文件中的类；
		* java.lang.reflect.Constructor:代表字节码文件中的构造方法字节码；
		* java.lang.reflect.filed：代表字节码文件中的属性；
		
	- 获取字节码文件
	
		* static Class forName(String className)：使用CLass类中的静态方法获取，其中className是带包名的字节码文件名
		* Class getClass（）：任何类中都有的方法，获取Class文件；
		
	- 使用class forName（）方法时会加载静态代码块；
	- 路径通用写法
		
		* Src是类的根路径；
		* String path = Thread.currentThred（）.getContextClassLoader（）.getResource（文件通用路径）.getPath（）；path就是路径；
		* InputStream reader = Thread.currentThread（）.getContextClassLoader（）.getResource（文件通用路径）：获取输入流；
	
	- 资源绑定器
		
		* 只能绑定属性配置文件；
		* static ResourceBundle getBundle（类路径）：使用ResourceBundle类中的该函数绑定属性配置文件； 
		
	- 类加载器
		
		* 负责加载类的工具：Classloader
		* 启动类加载器：加载jre/lib/rt.jre包下文件（最先启动）；
		* 扩展类加载器：加载jre/lib/ext/*.jre包下文件（启动类加载器中未找到类时启动）；
		* 应用类加载器：classpath文件夹中的文件（最后启动）；
		
	- 获取Class文件中全部Filed（属性）；
		
		* Field[] getFields():获取Class文件中公开Filed（属性）；
		* Field[] getDeclaredFields():获取Class文件中全部Filed（属性）；
		* 将修饰符代号转换为字符串：Modifier类中的Static String toString(代号);
	
	- 给对象赋值
	
		* Field类中的 void set（对象，赋的值），给对象取得的Field属性赋值；
		* 私有属性访问可以先打破封装：void setAccessible（true）；再进行访问；
		
	- 可变长度参数
	
		* 语法：数据类型...（数据类型后面跟三个.）；
		* 要求的参数个数为0~n；
		* 可变长度参数只能在最后一个位置上，且在参数列表中只能出现一个；
		* 可变长度参数可以当做一个数组；
		
	- 通过反射机制调用方法
	
		* Object invoke(对象，实参)；调用对象中的方法；
		
	- 通过反射机制创建对象；
	
		* newInstence方法创建对象；
	
	- 获取父类：getSuperClass（）方法；
	- 获取接口：getInnerface（）方法；
	
第二十二章 注解（Annotation）

	- 引用数据类型；
	- 定义注解： 修饰符列表 interface 注解名{}
	- 使用
	
		* 语法格式：@注解类型名
		* 注解可以出现在任何位置；
		
	- override注解（标识型注解）；
	
		* 只能注解方法；		
		* override注解是给编译器检查的；
		* 如果不是重写父类的方法，编译器会报错；
	
	- 元注解（用来标注注解的注解）
	
		* Target 用来标注被标注的注解能出现在哪些位置上；
		* Retention 用来标注被标注的注解最终能被保存在那个位置；
		
			- retentionPolicy.SOURCE:注解只能被保存在源文件中；
			- retentionPolicy.CLASS:注解会被保存在class文件中；
			- retentionPolicy.RUNTIME:注解会被保存在class文件中，且能被反射机制读取；
			
		* Deprecated 用来表示某个元素过时了；
	
	- 注解当中定义的属性；
		
		* 如果注解中有属性，使用注解时应该给属性赋值；
		* 属性名只有value的情况下，使用注解是value可以省略；
	
	- 注解在程序中相当于一个标记；		